<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' https: data: blob:; script-src 'self' 'unsafe-inline' 'unsafe-eval' https:; style-src 'self' 'unsafe-inline' https:; img-src 'self' data: https:; font-src 'self' https:; connect-src 'self' https:;">
    <title>Omega Terminal - Mining Interface</title>
    <script src="https://cdn.ethers.io/lib/ethers-5.7.2.umd.min.js" type="application/javascript"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #000;
            color: #ffffff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
            overflow: hidden;
        }

        .terminal {
            width: 100vw;
            height: 100vh;
            padding: 20px;
            background: linear-gradient(135deg, #000 0%, #111111 100%);
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .terminal-header {
            border-bottom: 1px solid #ffffff;
            padding-bottom: 10px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .terminal-title {
            font-size: 28px;
            font-weight: bold;
            text-shadow: 0 0 15px #ffffff, 0 0 30px #ffffff;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .terminal-status {
            font-size: 12px;
            color: #cccccc;
        }

        .theme-toggle {
            width: 22px;
            height: 22px;
            background: transparent;
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: pointer;
            margin-right: 0;
            margin-left: 0;
            display: inline-block;
            transition: border-color 0.2s;
            box-sizing: border-box;
            outline: none;
        }

        .theme-toggle:hover {
            border-color: #99ccff;
            background: rgba(255,255,255,0.05);
        }

        .terminal-input-section {
            border-top: 1px solid #ffffff;
            padding-top: 10px;
            margin-top: auto;
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #ffffff;
        }

        .terminal-content {
            flex: 1;
            overflow-y: auto;
            padding-right: 10px;
            margin-bottom: 20px;
            user-select: text !important;
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
        }

        .terminal-line {
            margin-bottom: 5px;
            word-wrap: break-word;
        }

        .prompt {
            color: #ffffff;
            font-weight: bold;
        }

        .command {
            color: #ffffff;
        }

        .output {
            color: #cccccc;
            margin-left: 20px;
            user-select: text !important;
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
        }

        .error {
            color: #ff6666;
        }

        .success {
            color: #ffffff;
        }

        .warning {
            color: #ffffcc;
        }

        .info {
            color: #99ccff;
        }

        .mining-status {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #ffffff;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #111111;
            border: 1px solid #ffffff;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffffff, #cccccc);
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px #ffffff;
        }

        .input-line {
            display: flex;
            align-items: center;
            background: transparent;
        }

        .input-prompt {
            color: #ffffff;
            font-weight: bold;
            margin-right: 10px;
            font-size: 16px;
        }

        .input-field {
            background: transparent;
            border: none;
            color: #ffffff;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            outline: none;
            flex: 1;
            padding: 5px;
        }

        .input-field::placeholder {
            color: #666666;
        }

        .cursor {
            animation: blink 1s infinite;
            color: #ffffff;
            font-size: 16px;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .mining-animation {
            display: inline-block;
            animation: mining-pulse 2s infinite;
        }

        @keyframes mining-pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }

        .stat-box {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #ffffff;
            padding: 10px;
            border-radius: 5px;
        }

        .stat-label {
            color: #cccccc;
            font-size: 12px;
        }

        .stat-value {
            color: #ffffff;
            font-size: 16px;
            font-weight: bold;
        }

        /* Boot Animation Styles */
        .boot-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            font-family: 'Courier New', monospace;
        }

        .omega-symbols {
            font-size: 48px;
            color: #ffffff;
            text-shadow: 0 0 20px #ffffff;
            margin-bottom: 20px;
            animation: omega-float 3s ease-in-out infinite;
        }

        .pickaxe {
            font-size: 36px;
            color: #ffcc00;
            text-shadow: 0 0 15px #ffcc00;
            animation: pickaxe-swing 2s ease-in-out infinite;
            margin-bottom: 30px;
        }

        .welcome-text {
            font-size: 24px;
            color: #ffffff;
            text-align: center;
            line-height: 1.5;
            text-shadow: 0 0 10px #ffffff;
        }

        .loading-dots {
            font-size: 18px;
            color: #cccccc;
            margin-top: 20px;
            animation: loading-pulse 1.5s ease-in-out infinite;
        }

        @keyframes omega-float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        @keyframes pickaxe-swing {
            0%, 100% { transform: rotate(-15deg); }
            50% { transform: rotate(15deg); }
        }

        @keyframes loading-pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        .hidden {
            display: none !important;
        }

        /* Light Theme Styles */
        .terminal.light-theme {
            background: linear-gradient(135deg, #f5f5f5 0%, #e0e0e0 100%);
            color: #000000;
        }

        .terminal.light-theme .terminal-header {
            border-bottom: 1px solid #000000;
        }

        .terminal.light-theme .terminal-title {
            color: #000000;
            text-shadow: 0 0 15px #000000, 0 0 30px #000000;
        }

        .terminal.light-theme .terminal-status {
            color: #333333;
        }

        .terminal.light-theme .theme-toggle {
            background: rgba(0, 0, 0, 0.1);
            border: 1px solid #000000;
            color: #000000;
        }

        .terminal.light-theme .theme-toggle:hover {
            background: rgba(0, 0, 0, 0.2);
        }

        .terminal.light-theme .terminal-input-section {
            border-top: 1px solid #000000;
            background: rgba(0, 0, 0, 0.05);
            border: 1px solid #000000;
        }

        .terminal.light-theme .prompt {
            color: #000000;
        }

        .terminal.light-theme .command {
            color: #000000;
        }

        .terminal.light-theme .output {
            color: #333333;
        }

        .terminal.light-theme .error {
            color: #cc0000;
        }

        .terminal.light-theme .success {
            color: #000000;
        }

        .terminal.light-theme .warning {
            color: #cc6600;
        }

        .terminal.light-theme .info {
            color: #0066cc;
        }

        .terminal.light-theme .input-prompt {
            color: #000000;
        }

        .terminal.light-theme .input-field {
            color: #000000;
        }

        .terminal.light-theme .input-field::placeholder {
            color: #666666;
        }

        .terminal.light-theme .cursor {
            color: #000000;
        }

        .terminal.light-theme .mining-status {
            background: rgba(0, 0, 0, 0.1);
            border: 1px solid #000000;
        }

        .terminal.light-theme .stat-box {
            background: rgba(0, 0, 0, 0.05);
            border: 1px solid #000000;
        }

        .terminal.light-theme .stat-label {
            color: #333333;
        }

        .terminal.light-theme .stat-value {
            color: #000000;
        }

        .output.error {
            color: #ff3333 !important;
            font-weight: bold !important;
        }

        /* --- FORCE RED AND BOLD FOR ERROR OUTPUT --- */
        .terminal-content .output.error,
        .output.error {
            color: #ff3333 !important;
            font-weight: bold !important;
        }

        .terminal-content, .output, .output.error, .output.success, .output.info, .output.warning,
        .terminal-content *, .output *, .output.error *, .output.success *, .output.info *, .output.warning * {
            user-select: text !important;
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
        }

        .terminal-line .copyable {
            cursor: pointer;
            text-decoration: underline;
            color: #00ff00;
            transition: all 0.3s ease;
        }
        
        .terminal-line .copyable:hover {
            color: #ffff00;
            text-shadow: 0 0 10px #ffff00;
        }
        
        .terminal-line .copyable:active {
            color: #ff0000;
        }

        body.theme-dark {
            background: #000;
            color: #fff;
        }
        body.theme-light {
            background: #fff;
            color: #111;
        }
        body.theme-matrix {
            background: #000;
            color: #00ff00;
        }
        body.theme-retro {
            background: #111;
            color: #39ff14;
        }
        .theme-matrix .terminal-header, .theme-retro .terminal-header {
            border-bottom: 1px solid #00ff00;
        }
        .theme-matrix .input-prompt, .theme-retro .input-prompt {
            color: #39ff14;
        }
        .theme-retro .input-prompt {
            color: orange;
        }
    </style>
</head>
<body>
    <!-- Boot Animation -->
    <div class="boot-animation" id="bootAnimation">
        <div class="omega-symbols">Œ© Œ© Œ© Œ© Œ©</div>
        <div class="pickaxe">‚õèÔ∏è</div>
        <div class="welcome-text">
            Welcome to Omega Terminal v1<br>
            <span style="font-size: 16px; color: #cccccc;">Type below to get started</span>
        </div>
        <div class="loading-dots">Loading...</div>
    </div>

    <div class="terminal" id="terminal" style="display: none;">
        <div class="terminal-header">
            <div class="terminal-title">Omega Terminal v1.0.2</div>
            <div style="display: flex; align-items: center; gap: 18px; margin-left: auto;">
                <button class="theme-toggle" title="Toggle Theme"></button>
                <div class="terminal-status" id="connectionStatus">DISCONNECTED</div>
            </div>
        </div>
        
        <div class="terminal-content" id="terminalContent">
            <div class="terminal-line">
                <span class="prompt">root@omega-miner:~$</span>
                <span class="command"> ./omega-miner --version</span>
            </div>
            <div class="output">Omega Mining Terminal v1.0.0</div>
            <div class="output">Connected to Omega Network (Chain ID: 1313161768)</div>
            <div class="output">Mining Contract: <span id="contractAddress">Not deployed</span></div>
            <div class="terminal-line">
                <span class="prompt">root@omega-miner:~$</span>
                <span class="command"> ./omega-miner --help</span>
            </div>
            <div class="output error">Type 'help' to see a list of commands</div>
        </div>

        <div class="terminal-input-section">
            <div class="input-line">
                <span class="input-prompt">root@omega-miner:~$</span>
                <input type="text" class="input-field" id="commandInput" placeholder="Enter command..." autocomplete="off">
                <span class="cursor">|</span>
            </div>
        </div>
    </div>

    <script>
        // Simplified ethers loading with fallback support
        function loadEthers() {
            return new Promise((resolve, reject) => {
                // Small delay to ensure CDN script has time to load
                setTimeout(() => {
                    console.log('Checking for ethers availability...');
                    
                    // Check if ethers is already loaded (CDN success)
                    if (typeof ethers !== 'undefined') {
                        console.log('Ethers loaded successfully from CDN');
                        resolve(ethers);
                        return;
                    }
                    
                    console.log('CDN ethers not loaded, trying additional CDN sources...');
                    
                    // Try multiple CDN sources
                    const cdnSources = [
                        'https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js',
                        'https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js'
                    ];
                    
                    let currentSource = 0;
                    
                    function tryNextSource() {
                        if (currentSource >= cdnSources.length) {
                            // All CDN sources failed, load fallback
                            console.log('All CDN sources failed, loading fallback ethers...');
                            loadEthersFallback();
                            resolve(ethers);
                            return;
                        }
                        
                        const script = document.createElement('script');
                        script.src = cdnSources[currentSource];
                        script.onload = () => {
                            if (typeof ethers !== 'undefined') {
                                console.log(`Ethers loaded successfully from: ${cdnSources[currentSource]}`);
                                resolve(ethers);
                            } else {
                                currentSource++;
                                tryNextSource();
                            }
                        };
                        script.onerror = () => {
                            console.warn(`Failed to load ethers from: ${cdnSources[currentSource]}`);
                            currentSource++;
                            tryNextSource();
                        };
                        document.head.appendChild(script);
                    }
                    
                    tryNextSource();
                }, 500); // 500ms delay to ensure CDN script has time to load
            });
        }

        // Fallback ethers implementation - only loads if all CDN sources fail
        function loadEthersFallback() {
            console.log('Loading ethers fallback...');
            window.ethers = {
                providers: {
                    Web3Provider: function(provider) {
                        this.provider = provider;
                        this.getSigner = () => ({ 
                            getAddress: () => Promise.resolve('0x0000000000000000000000000000000000000000'),
                            sendTransaction: () => Promise.reject(new Error('Fallback ethers - no real transactions'))
                        });
                        this.getGasPrice = () => Promise.resolve({ toString: () => '20000000000' });
                        this.getBalance = () => Promise.resolve({ isZero: () => true });
                        this.getTransactionCount = () => Promise.resolve(0);
                    }
                },
                Contract: function(address, abi, signer) {
                    this.address = address;
                    this.abi = abi;
                    this.signer = signer;
                    // Add basic contract methods
                    this.startMining = () => Promise.resolve({ wait: () => Promise.resolve() });
                    this.claimRewards = () => Promise.resolve({ wait: () => Promise.resolve() });
                },
                Wallet: {
                    createRandom: function() {
                        return {
                            address: '0x' + Math.random().toString(16).substr(2, 40),
                            privateKey: '0x' + Math.random().toString(16).substr(2, 64),
                            connect: function(provider) { return this; },
                            sendTransaction: function(tx) { 
                                return Promise.resolve({ 
                                    hash: '0x' + Math.random().toString(16).substr(2, 64),
                                    wait: () => Promise.resolve()
                                }); 
                            }
                        };
                    }
                },
                utils: {
                    formatEther: (wei) => (parseInt(wei) / 1e18).toString(),
                    parseEther: (ether) => (parseFloat(ether) * 1e18).toString(),
                    id: (text) => '0x' + Math.random().toString(16).substr(2, 64),
                    defaultAbiCoder: {
                        decode: () => ['0x0000000000000000000000000000000000000000', '1000000000000000000', '1']
                    },
                    hexDataSlice: (data, start) => data
                }
            };
            console.log('Ethers fallback loaded successfully');
        }

        class OmegaMinerTerminal {
            constructor() {
                this.provider = null;
                this.signer = null;
                this.contract = null;
                this.isMining = false;
                this.miningInterval = null;
                this.currentNonce = 0;
                this.ethers = null;
                this.isDarkTheme = true; // Default to dark theme
                
                // New mining system properties
                this.pendingClaimableBalance = 0;
                this.totalEarned = 0; // Track total earned during session
                this.waitingForContinueResponse = false;
                
                // Stress test properties
                this.isStressTesting = false;
                this.stressTestInterval = null;
                this.stressTestStats = {
                    walletsCreated: 0,
                    transactionsSent: 0,
                    successfulTxs: 0,
                    failedTxs: 0,
                    startTime: 0
                };
                this.stressWallet = null;
                this.stressNonce = 0;
                
                // Contract properties
                this.contractAddress = '0x0d4a5d6d28ce3d79dfd145b3ca5286a50c2f9895'; // Deployed OmegaMiner contract
                this.faucetAddress = '0xda30bfb82aa9b16b63fa97aafb1bfa7c9101c81b'; // Deployed OmegaFaucet contract
                this.minerFaucetAddress = '0x1c4ffffcc804ba265f6cfccffb94d0ae28b36207'; // Deployed OmegaMinerFaucet contract
                this.contractABI = [
                    "function depositForMining() external payable",
                    "function startMining() external",
                    "function mineBlock(uint256 nonce, bytes32 solution) external",
                    "function claimRewards() external",
                    "function getMinerInfo(address miner) external view returns (uint256, uint256, uint256, bool, uint256)",
                    "function getContractStats() external view returns (uint256, uint256, uint256)",
                    "function miningDifficulty() external view returns (uint256)",
                    "function mineCooldown() external view returns (uint256)",
                    "function maxRewardPerUser() external view returns (uint256)",
                    "event TokensDeposited(address indexed user, uint256 amount)",
                    "event MiningStarted(address indexed user)",
                    "event BlockMined(address indexed user, uint256 nonce, bytes32 solution, uint256 reward)",
                    "event WholeBlockMined(address indexed user, uint256 nonce, bytes32 solution)",
                    "event RewardsClaimed(address indexed user, uint256 amount)"
                ];
                this.faucetABI = [
                    {
                        "inputs": [],
                        "name": "claim",
                        "outputs": [],
                        "stateMutability": "nonpayable",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "emergencyWithdraw",
                        "outputs": [],
                        "stateMutability": "nonpayable",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "stateMutability": "nonpayable",
                        "type": "constructor"
                    },
                    {
                        "anonymous": false,
                        "inputs": [
                            {
                                "indexed": false,
                                "internalType": "uint256",
                                "name": "amount",
                                "type": "uint256"
                            }
                        ],
                        "name": "FaucetRefilled",
                        "type": "event"
                    },
                    {
                        "inputs": [],
                        "name": "refillFaucet",
                        "outputs": [],
                        "stateMutability": "payable",
                        "type": "function"
                    },
                    {
                        "anonymous": false,
                        "inputs": [
                            {
                                "indexed": true,
                                "internalType": "address",
                                "name": "user",
                                "type": "address"
                            },
                            {
                                "indexed": false,
                                "internalType": "uint256",
                                "name": "amount",
                                "type": "uint256"
                            },
                            {
                                "indexed": false,
                                "internalType": "uint256",
                                "name": "timestamp",
                                "type": "uint256"
                            }
                        ],
                        "name": "TokensClaimed",
                        "type": "event"
                    },
                    {
                        "inputs": [],
                        "name": "withdrawFaucet",
                        "outputs": [],
                        "stateMutability": "nonpayable",
                        "type": "function"
                    },
                    {
                        "stateMutability": "payable",
                        "type": "receive"
                    },
                    {
                        "inputs": [
                            {
                                "internalType": "address",
                                "name": "user",
                                "type": "address"
                            }
                        ],
                        "name": "canClaim",
                        "outputs": [
                            {
                                "internalType": "bool",
                                "name": "",
                                "type": "bool"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "CLAIM_AMOUNT",
                        "outputs": [
                            {
                                "internalType": "uint256",
                                "name": "",
                                "type": "uint256"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "CLAIM_COOLDOWN",
                        "outputs": [
                            {
                                "internalType": "uint256",
                                "name": "",
                                "type": "uint256"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "faucetBalance",
                        "outputs": [
                            {
                                "internalType": "uint256",
                                "name": "",
                                "type": "uint256"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [
                            {
                                "internalType": "address",
                                "name": "user",
                                "type": "address"
                            }
                        ],
                        "name": "getClaimInfo",
                        "outputs": [
                            {
                                "internalType": "bool",
                                "name": "canClaimNow",
                                "type": "bool"
                            },
                            {
                                "internalType": "uint256",
                                "name": "lastClaim",
                                "type": "uint256"
                            },
                            {
                                "internalType": "uint256",
                                "name": "timeUntilNextClaim",
                                "type": "uint256"
                            },
                            {
                                "internalType": "uint256",
                                "name": "claimAmount",
                                "type": "uint256"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "getFaucetBalance",
                        "outputs": [
                            {
                                "internalType": "uint256",
                                "name": "",
                                "type": "uint256"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [
                            {
                                "internalType": "address",
                                "name": "user",
                                "type": "address"
                            }
                        ],
                        "name": "getTimeUntilNextClaim",
                        "outputs": [
                            {
                                "internalType": "uint256",
                                "name": "",
                                "type": "uint256"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [
                            {
                                "internalType": "address",
                                "name": "",
                                "type": "address"
                            }
                        ],
                        "name": "lastClaimTime",
                        "outputs": [
                            {
                                "internalType": "uint256",
                                "name": "",
                                "type": "uint256"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "totalClaims",
                        "outputs": [
                            {
                                "internalType": "uint256",
                                "name": "",
                                "type": "uint256"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    }
                ];
                this.minerFaucetABI = [
                    {
                        "inputs": [],
                        "name": "mine",
                        "outputs": [],
                        "stateMutability": "payable",
                        "type": "function"
                    },
                    {
                        "inputs": [{"internalType": "address", "name": "", "type": "address"}],
                        "name": "totalMined",
                        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [{"internalType": "address", "name": "", "type": "address"}],
                        "name": "lastMineTime",
                        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                        "stateMutability": "view",
                        "type": "function"
                    }
                ];
                
                this.loadTheme();
                this.init();
            }
            
            async init() {
                console.log('OmegaMinerTerminal initializing...');
                // Show boot animation first
                await this.showBootAnimation();
                // Always set up event listeners immediately after boot
                this.setupEventListeners();
                try {
                    console.log('Loading ethers library...');
                    this.ethers = await loadEthers();
                    console.log('Ethers library loaded successfully');
                    this.log('Ethers library loaded successfully', 'success');
                    this.checkWalletConnection();
                } catch (error) {
                    console.error('Failed to load ethers:', error);
                    this.log('Failed to load ethers library: ' + error.message, 'error');
                    this.log('Please check your internet connection and refresh the page', 'error');
                }
            }
            
            loadTheme() {
                const theme = localStorage.getItem('omega-terminal-theme') || 'dark';
                document.body.classList.remove('theme-dark', 'theme-light', 'theme-matrix', 'theme-retro');
                document.body.classList.add('theme-' + theme);
            }
            
            async showBootAnimation() {
                console.log('Showing boot animation...');
                return new Promise((resolve) => {
                    setTimeout(() => {
                        console.log('Hiding boot animation, showing terminal...');
                        // Hide boot animation and show terminal
                        document.getElementById('bootAnimation').style.display = 'none';
                        document.getElementById('terminal').style.display = 'flex';
                        
                        // Apply theme after terminal is shown
                        this.applyTheme();
                        
                        console.log('Terminal ready!');
                        resolve();
                    }, 3000); // Show animation for 3 seconds
                });
            }
            
            setupEventListeners() {
                const input = document.getElementById('commandInput');
                if (input) {
                    input.focus();
                    // Bind the event handler to the class instance
                    const boundExecuteCommand = this.executeCommand.bind(this);
                    input.addEventListener('keypress', function(e) {
                        if (e.key === 'Enter') {
                            boundExecuteCommand(input.value);
                            input.value = '';
                        }
                        // Ctrl+C to stop stress test
                        if (e.key === 'c' && e.ctrlKey) {
                            // 'this' is not needed here, as isStressTesting is not used in this context
                        }
                    });
                    // Fallback: refocus input if user clicks anywhere in the terminal
                    document.getElementById('terminal').addEventListener('click', function() {
                        input.focus();
                    });
                }
                // Setup theme toggle
                const themeToggle = document.querySelector('.theme-toggle');
                if (themeToggle) {
                    themeToggle.addEventListener('click', () => {
                        this.toggleTheme();
                    });
                    // Remove emoji/text, just hollow circle
                    themeToggle.textContent = '';
                }
            }
            
            async checkWalletConnection() {
                if (typeof window.ethereum !== 'undefined') {
                    try {
                        const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                        if (accounts.length > 0) {
                            await this.connectWallet();
                        }
                    } catch (error) {
                        this.log('Error checking wallet connection: ' + error.message, 'error');
                    }
                }
            }
            
            async connectWallet() {
                try {
                    if (!this.ethers) {
                        this.log('Ethers library not loaded. Please refresh the page.', 'error');
                        return;
                    }

                    if (typeof window.ethereum === 'undefined') {
                        this.log('MetaMask not found. Please install MetaMask.', 'error');
                        return;
                    }
                    
                    this.log('üîó Connecting to MetaMask...', 'info');
                    
                    // Request account access
                    try {
                        await window.ethereum.request({ method: 'eth_requestAccounts' });
                        this.log('‚úÖ MetaMask account access granted', 'success');
                    } catch (requestError) {
                        this.log('‚ùå MetaMask connection denied by user', 'error');
                        return;
                    }
                    
                    this.provider = new this.ethers.providers.Web3Provider(window.ethereum);
                    this.signer = this.provider.getSigner();
                    
                    this.log('üîç Getting wallet address...', 'info');
                    const address = await this.signer.getAddress();
                    
                    // Check if we're using fallback ethers (which would return 0x000... address)
                    if (address === '0x0000000000000000000000000000000000000000') {
                        this.log('‚ö†Ô∏è Using fallback ethers - real transactions not available', 'warning');
                        this.log('üí° Please check your internet connection and refresh the page', 'info');
                        return;
                    }
                    
                    this.log(`‚úÖ Wallet connected: ${address}`, 'success');
                    this.updateConnectionStatus('CONNECTED');
                    
                    if (this.contractAddress !== '0x0000000000000000000000000000000000000000') {
                        this.contract = new this.ethers.Contract(this.contractAddress, this.contractABI, this.signer);
                        this.log('‚úÖ Mining contract connected', 'success');
                    }
                    
                } catch (error) {
                    console.error('Connect wallet error:', error);
                    this.log('‚ùå Failed to connect wallet: ' + error.message, 'error');
                    this.log('üí° Make sure MetaMask is unlocked and you approve the connection', 'info');
                }
            }
            
            async disconnectWallet() {
                try {
                    if (!this.signer) {
                        this.log('No wallet connected to disconnect.', 'warning');
                        return;
                    }
                    
                    // Get the address before disconnecting for the message
                    const address = await this.signer.getAddress();
                    
                    // Clear all wallet-related properties
                    this.provider = null;
                    this.signer = null;
                    this.contract = null;
                    this.pendingClaimableBalance = 0;
                    
                    this.log(`üîå Wallet disconnected: ${address}`, 'success');
                    this.updateConnectionStatus('DISCONNECTED');
                    this.log('üí° Use "connect" command to reconnect your wallet', 'info');
                    
                } catch (error) {
                    console.error('Disconnect wallet error:', error);
                    this.log('‚ùå Error disconnecting wallet: ' + error.message, 'error');
                }
            }
            
            async executeCommand(command) {
                const cmd = command.trim().toLowerCase();
                this.logCommand(command);
                
                // Handle continue mining response
                if (this.waitingForContinueResponse) {
                    this.waitingForContinueResponse = false;
                    if (cmd === 'yes' || cmd === 'y') {
                        this.log('‚úÖ Continuing mining...', 'success');
                        await this.startMiningStressTest();
                        return;
                    } else {
                        this.log('üëã Mining session ended. Thanks for mining!', 'info');
                        return;
                    }
                }
                
                if (cmd.startsWith('fund ')) {
                    const parts = cmd.split(' ');
                    let amount = parts[1];
                    if (!amount) {
                        this.log('Please specify the amount to fund. Usage: fund [amount]', 'info');
                        return;
                    }
                    await this.fundStressWallet(amount);
                    return;
                }
                
                if (cmd.startsWith('theme ')) {
                    const theme = cmd.split(' ')[1];
                    await this.setTheme(theme);
                    return;
                }
                
                switch (cmd) {
                    case 'connect':
                        await this.connectWallet();
                        break;
                    case 'disconnect':
                        await this.disconnectWallet();
                        break;
                    case 'mine':
                        await this.mine();
                        break;
                    case 'session':
                        await this.startMiningSession();
                        break;
                    case 'faucet':
                        await this.faucetClaim();
                        break;
                    case 'claim':
                        await this.claim();
                        break;
                    case 'pending':
                        await this.showPendingRewards();
                        break;
                    case 'balance':
                        await this.showBalance();
                        break;
                    case 'stop':
                        this.stopAll();
                        break;
                    case 'status':
                        await this.showStatus();
                        break;
                    case 'stats':
                        await this.showStats();
                        break;
                    case 'deposit':
                        await this.depositForMining();
                        break;
                    case 'deploy':
                        await this.deployContract();
                        break;
                    case 'contract':
                        await this.showContractInfo();
                        break;
                    case 'stress':
                        await this.startStressTest();
                        break;
                    case 'stopstress':
                        this.stopStressTest();
                        break;
                    case 'stressstats':
                        this.showStressStats();
                        break;
                    case 'theme':
                        this.toggleTheme();
                        this.log(`Theme switched to ${this.isDarkTheme ? 'dark' : 'light'} mode`, 'success');
                        break;
                    case 'help':
                        this.showHelp();
                        break;
                    case 'clear':
                        this.clearTerminal();
                        break;
                    case 'rickroll':
                        await this.rickroll();
                        break;
                    case 'fortune':
                        this.fortune();
                        break;
                    case 'matrix':
                        await this.matrix();
                        break;
                    case 'hack':
                        await this.hack();
                        break;
                    case 'disco':
                        await this.disco();
                        break;
                    case 'sudo mine':
                        this.sudoMine();
                        break;
                    case 'minestats':
                        await this.showMiningStats();
                        break;
                    default:
                        if (cmd) {
                            this.log(`Command not found: ${command}`, 'error');
                            this.log('Type "help" for available commands', 'info');
                        }
                }
            }
            
            async mine() {
                if (!this.signer) {
                    this.log('Please connect your wallet first using: connect', 'error');
                    return;
                }

                if (this.isMining) {
                    this.log('Mining is already in progress. Use "stop" to stop mining.', 'error');
                    return;
                }

                this.isMining = true;
                this.mineCount = 0;
                this.totalEarned = 0; // Reset earned amount for new session
                this.startTime = Date.now();
                this.log('üöÄ Welcome To Omega Terminal v1.1.1!', 'success');
                this.log('‚õèÔ∏è  Mining blocks with 70% reward chance (avg: 0.001 OMEGA, big: 0.01 OMEGA)', 'info');
                this.log('üí∞ Rewards accumulate locally - use "claim" to collect all at once', 'info');

                const mineInterval = setInterval(async () => {
                    if (!this.isMining) {
                        clearInterval(mineInterval);
                        return;
                    }

                    try {
                        this.mineCount++;
                        
                        // Generate fake mining progress
                        const difficulty = Math.floor(Math.random() * 8) + 4; // 4-12 leading zeros
                        const nonce = Math.floor(Math.random() * 1000000);
                        const blockHash = this.generateFakeHash();
                        
                        this.log(`‚õèÔ∏è  Mining block #${this.mineCount}...`, 'info');
                        this.log(`üéØ Target: ${'0'.repeat(difficulty)}...`, 'output');
                        this.log(`üî¢ Nonce: ${nonce}`, 'output');
                        this.log(`üì¶ Hash: ${blockHash}`, 'output');
                        
                        // Simulate mining time
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        
                        // Calculate reward (70% chance every block)
                        if (Math.random() < 0.7) {
                            const randomValue = Math.floor(Math.random() * 1000);
                            let reward;
                            
                            if (randomValue === 999) { // 0.1% chance for whole block
                                reward = 1.0;
                                this.log(`üèÜ WHOLE BLOCK MINED! +1.0 OMEGA`, 'success');
                            } else if (randomValue >= 950) { // 5% chance for bigger reward
                                reward = 0.01;
                                this.log(`üí∞ Big reward: +0.01 OMEGA`, 'success');
                            } else {
                                reward = (randomValue * 0.001) / 1000; // 0.001 average (10x more)
                                this.log(`üí∞ Block reward: +${reward.toFixed(6)} OMEGA`, 'success');
                            }
                            
                            this.totalEarned += reward;
                            this.log(`üí≥ Total earned this session: ${this.totalEarned.toFixed(6)} OMEGA`, 'info');
                        } else {
                            this.log(`‚õèÔ∏è  Block mined (no reward this time)`, 'output');
                        }
                        
                    } catch (error) {
                        this.log(`‚ùå Mining failed: ${error.message}`, 'error');
                    }
                }, 10000); // Mine every 10 seconds (faster for better UX)

                this.log('Mining started. Use "stop" to stop mining, "claim" to collect rewards.', 'info');
            }
            
            generateFakeHash() {
                const chars = '0123456789abcdef';
                let hash = '0x';
                for (let i = 0; i < 64; i++) {
                    hash += chars[Math.floor(Math.random() * chars.length)];
                }
                return hash;
            }
            
            async claim() {
                if (!this.signer) {
                    this.log('Please connect wallet first using "connect" command', 'error');
                    return;
                }
                
                if (this.totalEarned <= 0) {
                    this.log('‚ùå No rewards available to claim. Mine first to earn rewards!', 'warning');
                    return;
                }
                
                try {
                    const address = await this.signer.getAddress();
                    const rewardAmount = this.totalEarned;
                    
                    this.log(`üí∞ Claiming ${rewardAmount.toFixed(6)} OMEGA...`, 'info');
                    this.log('‚è≥ Processing reward transfer...', 'info');
                    
                    // Check pending rewards before attempting claim
                    const minerInfo = await this.contract.getMinerInfo(address);
                    const pendingRewards = minerInfo[4]; // pendingRewards is the 5th return value
                    const minClaim = this.ethers.utils.parseEther('0.1');
                    if (pendingRewards < minClaim) {
                        this.log('‚ö†Ô∏è Minimum claim amount is 0.1 OMEGA. Keep mining to accumulate more before claiming.', 'warning');
                        return;
                    }
                    
                    // Minimal ABI for native faucet
                    const faucetAbi = [
                        { "inputs": [], "name": "claimReward", "outputs": [], "stateMutability": "nonpayable", "type": "function" }
                    ];
                    const faucetContract = new this.ethers.Contract(
                        this.faucetAddress,
                        faucetAbi,
                        this.signer
                    );
                    try {
                        this.log('ü™ô Processing reward transfer...', 'info');
                        const tx = await faucetContract.claimReward({ gasLimit: 100000 });
                        await tx.wait();
                        this.log('‚úÖ Reward claimed! OMEGA sent to your wallet.', 'success');
                        this.totalEarned = 0;
                    } catch (err) {
                        this.log('‚ùå Failed to claim rewards: ' + (err && err.message ? err.message : err), 'error');
                    }
                    
                } catch (error) {
                    console.error('Claim error:', error);
                    this.log(`‚ùå Failed to claim rewards: ${error.message}`, 'error');
                }
            }
            
            // Add missing methods that are referenced in the code
            logCommand(command) {
                const terminalContent = document.getElementById('terminalContent');
                const line = document.createElement('div');
                line.className = 'terminal-line';
                line.innerHTML = `<span class="prompt">root@omega-miner:~$</span><span class="command"> ${command}</span>`;
                terminalContent.appendChild(line);
                terminalContent.scrollTop = terminalContent.scrollHeight;
            }
            
            log(message, type = 'output') {
                const terminalContent = document.getElementById('terminalContent');
                const line = document.createElement('div');
                line.className = `output ${type}`;
                line.textContent = message;
                terminalContent.appendChild(line);
                terminalContent.scrollTop = terminalContent.scrollHeight;
            }
            
            logHtml(html, type = 'output') {
                const terminalContent = document.getElementById('terminalContent');
                const line = document.createElement('div');
                line.className = `terminal-line ${type}`;
                line.innerHTML = html;
                terminalContent.appendChild(line);
                terminalContent.scrollTop = terminalContent.scrollHeight;
            }
            
            clearTerminal() {
                const terminalContent = document.getElementById('terminalContent');
                terminalContent.innerHTML = '';
            }
            
            updateConnectionStatus(status) {
                const statusElement = document.getElementById('connectionStatus');
                if (statusElement) {
                    statusElement.textContent = status;
                }
            }
            
            showHelp() {
                this.log('=== Available Commands ===', 'info');
                this.log('Connect:      [connect] | Disconnect: [disconnect]', 'output');
                this.log('Theme:        [theme dark] [theme light] [theme matrix] [theme retro]', 'output');
                this.log('Mine:         [mine] | Claim: [claim]', 'output');
                this.log('Faucet:       [faucet] | Balance: [balance]', 'output');
                this.log('Status:       [status] | Stats: [stats]', 'output');
                this.log('Stress Test:  [stress] | Stop Stress: [stopstress] | Stress Stats: [stressstats]', 'output');
                this.log('Fund Stress Wallet: [fund <amount>]', 'output');
                this.log('Clear:        [clear] | Help: [help]', 'output');
                this.log('Fun:          [rickroll] [fortune] [matrix] [hack] [disco] [sudo mine]', 'output');
            }
            
            async showBalance() {
                if (!this.signer) {
                    this.log('Please connect your wallet first using: connect', 'error');
                    return;
                }
                
                try {
                    const address = await this.signer.getAddress();
                    const balance = await this.provider.getBalance(address);
                    const omegaBalance = this.ethers.utils.formatEther(balance);
                    
                    this.log(` Wallet Balance: ${omegaBalance} OMEGA`, 'success');
                    this.log(`üìç Address: ${address}`, 'info');
                    this.log(`üí≥ Pending Rewards: ${this.totalEarned.toFixed(6)} OMEGA`, 'info');
                } catch (error) {
                    this.log('‚ùå Failed to get balance: ' + error.message, 'error');
                }
            }
            
            async showStatus() {
                if (!this.signer) {
                    this.log('‚ùå Wallet not connected', 'error');
                    return;
                }
                
                try {
                    const address = await this.signer.getAddress();
                    this.log(`‚úÖ Wallet: ${address}`, 'success');
                    this.log(`‚õèÔ∏è  Mining: ${this.isMining ? 'Active' : 'Inactive'}`, 'info');
                    this.log(`üí∞ Pending: ${this.totalEarned.toFixed(6)} OMEGA`, 'info');
                    this.log(`üìä Blocks Mined: ${this.mineCount || 0}`, 'info');
                } catch (error) {
                    this.log('‚ùå Failed to get status: ' + error.message, 'error');
                }
            }
            
            async showStats() {
                this.log('üìä Mining Statistics:', 'info');
                this.log(`‚õèÔ∏è  Total Blocks: ${this.mineCount || 0}`, 'output');
                this.log(`üí∞ Total Earned: ${this.totalEarned.toFixed(6)} OMEGA`, 'output');
                this.log(`‚è±Ô∏è  Session Time: ${this.startTime ? Math.floor((Date.now() - this.startTime) / 1000) : 0}s`, 'output');
            }
            
            stopAll() {
                let stoppedActivities = [];
                
                // Stop mining
                if (this.isMining) {
                    this.isMining = false;
                    if (this.miningInterval) {
                        clearInterval(this.miningInterval);
                        this.miningInterval = null;
                    }
                    stoppedActivities.push('mining');
                }
                
                // Stop stress testing
                if (this.isStressTesting) {
                    this.isStressTesting = false;
                    if (this.stressTestInterval) {
                        clearInterval(this.stressTestInterval);
                        this.stressTestInterval = null;
                    }
                    stoppedActivities.push('stress testing');
                }
                
                if (stoppedActivities.length > 0) {
                    this.log(`‚èπÔ∏è  Stopped: ${stoppedActivities.join(', ')}`, 'success');
                } else {
                    this.log('‚èπÔ∏è  No activities were running to stop', 'info');
                }
            }
            
            async startMiningSession() {
                this.log('üöÄ Starting mining session...', 'info');
                await this.mine();
            }
            
            async faucetClaim() {
                if (!this.signer) {
                    this.log('Please connect your wallet first using: connect', 'error');
                    return;
                }
                
                try {
                    this.log('üö∞ Claiming from faucet...', 'info');
                    const faucetContract = new this.ethers.Contract(this.faucetAddress, this.faucetABI, this.signer);
                    const tx = await faucetContract.claim({ gasLimit: 100000 });
                    await tx.wait();
                    this.log('‚úÖ Faucet claim successful!', 'success');
                } catch (error) {
                    this.log('‚ùå Faucet claim failed: ' + error.message, 'error');
                }
            }
            
            async showPendingRewards() {
                this.log(`üí∞ Pending Rewards: ${this.totalEarned.toFixed(6)} OMEGA`, 'info');
                if (this.totalEarned > 0) {
                    this.log('üí° Use "claim" command to collect rewards', 'info');
                }
            }
            
            async depositForMining() {
                this.log('üí° This feature is not yet implemented', 'info');
            }
            
            async deployContract() {
                this.log('üí° Contract deployment is handled separately', 'info');
            }
            
            async showContractInfo() {
                this.log(`üìã Mining Contract: ${this.contractAddress}`, 'info');
                this.log(`üö∞ Faucet Contract: ${this.faucetAddress}`, 'info');
            }
            
            async startStressTest() {
                if (!this.ethers) {
                    this.log('Ethers library not loaded. Please refresh the page.', 'error');
                    return;
                }
                
                if (this.isStressTesting) {
                    this.log('Stress test already running. Use "stopstress" to stop it.', 'warning');
                    return;
                }
                
                // Generate a new wallet for the stress test
                this.stressWallet = this.ethers.Wallet.createRandom();
                this.log('üÜï Stress Test Wallet Generated:', 'info');
                this.logHtml(`Address: <span class="copyable" onclick="navigator.clipboard.writeText('${this.stressWallet.address}').then(() => window.terminal.log('‚úÖ Address copied to clipboard!', 'success')).catch(() => window.terminal.log('‚ùå Failed to copy address', 'error'))">${this.stressWallet.address}</span>`, 'output');
                this.log(`Private Key: ${this.stressWallet.privateKey}`, 'warning');
                this.log('[Fund this address with a small amount of OMEGA for gas. Tokens sent here are unrecoverable!]', 'warning');
                
                // Add copy functionality
                this.log('üí° Click the address above to copy it, or type "fund [amount]" to send OMEGA from your connected wallet', 'info');
                
                // Connect wallet to provider
                this.stressWallet = this.stressWallet.connect(this.provider);
                
                // Wait for funding
                this.log('‚è≥ Waiting for funding to initiate stress test...', 'info');
                this.isStressTesting = true;
                this.stressTestStats = {
                    walletsCreated: 0,
                    transactionsSent: 0,
                    successfulTxs: 0,
                    failedTxs: 0,
                    startTime: Date.now()
                };
                
                // Poll for funding every 5 seconds
                this.stressFundingInterval = setInterval(async () => {
                    const balance = await this.provider.getBalance(this.stressWallet.address);
                    if (!balance.isZero()) {
                        clearInterval(this.stressFundingInterval);
                        this.log('‚úÖ Funding detected! Starting stress test...', 'success');
                        // Fetch and store the starting nonce
                        this.localNonce = await this.provider.getTransactionCount(this.stressWallet.address, 'latest');
                        this.startStressTestCycle();
                    }
                }, 5000);
            }

            startStressTestCycle() {
                this.stressTestInterval = setInterval(() => {
                    if (this.isStressTesting) {
                        this.runStressTestCycle();
                    }
                }, 3000);
                this.log('‚úÖ Stress test will now begin!', 'success');
            }

            async runStressTestCycle() {
                try {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    const newWallet = this.ethers.Wallet.createRandom();
                    this.stressTestStats.walletsCreated++;
                    const gasPrice = await this.provider.getGasPrice();
                    
                    // Use and increment local nonce
                    const nonce = this.localNonce;
                    this.localNonce++;
                    
                    const tx = await this.stressWallet.sendTransaction({
                        to: newWallet.address,
                        value: 0,
                        gasLimit: 21000,
                        gasPrice: gasPrice,
                        nonce: nonce
                    });
                    
                    this.stressTestStats.transactionsSent++;
                    this.log(`üì§ Sent empty tx to ${newWallet.address.slice(0, 10)}... (hash: ${tx.hash.slice(0, 10)}...)`, 'info');
                    this.stressTestStats.successfulTxs++;
                    
                } catch (err) {
                    this.stressTestStats.failedTxs++;
                    // If nonce error, re-sync local nonce
                    if (err.message && (err.message.includes('nonce') || err.message.includes('replacement'))) {
                        this.log('üîÑ Nonce error detected, re-syncing nonce from network...', 'warning');
                        this.localNonce = await this.provider.getTransactionCount(this.stressWallet.address, 'latest');
                    } else if (err.message && err.message.includes('Internal JSON-RPC error')) {
                        this.log(`‚ö†Ô∏è RPC overload - slowing down...`, 'warning');
                        await new Promise(resolve => setTimeout(resolve, 2000));
                    } else {
                        this.log(`‚ùå Transaction failed: ${err.message}`, 'error');
                    }
                }
            }

            stopStressTest() {
                if (!this.isStressTesting) {
                    this.log('No stress test running.', 'warning');
                    return;
                }
                
                if (this.stressTestInterval) {
                    clearInterval(this.stressTestInterval);
                }
                if (this.stressFundingInterval) {
                    clearInterval(this.stressFundingInterval);
                }
                
                this.isStressTesting = false;
                this.log('üõë Stress test stopped.', 'warning');
                this.showStressStats();
            }
            
            showStressStats() {
                if (!this.stressTestStats.startTime) {
                    this.log('No stress test has been run yet.', 'info');
                    return;
                }
                
                const runtime = Math.floor((Date.now() - this.stressTestStats.startTime) / 1000);
                const successRate = this.stressTestStats.transactionsSent > 0 
                    ? ((this.stressTestStats.successfulTxs / this.stressTestStats.transactionsSent) * 100).toFixed(1)
                    : 0;
                
                this.log('=== STRESS TEST STATISTICS ===', 'info');
                this.log(`Runtime: ${runtime} seconds`, 'output');
                this.log(`Wallets Created: ${this.stressTestStats.walletsCreated}`, 'output');
                this.log(`Transactions Sent: ${this.stressTestStats.transactionsSent}`, 'output');
                this.log(`Successful: ${this.stressTestStats.successfulTxs}`, 'success');
                this.log(`Failed: ${this.stressTestStats.failedTxs}`, 'error');
                this.log(`Success Rate: ${successRate}%`, 'output');
                this.log(`Status: ${this.isStressTesting ? 'RUNNING' : 'STOPPED'}`, this.isStressTesting ? 'success' : 'warning');
            }
            
            async showMiningStats() {
                await this.showStats();
            }
            
            async rickroll() {
                this.log('üéµ Never gonna give you up...', 'info');
                this.log('üéµ Never gonna let you down...', 'info');
                this.log('üéµ Never gonna run around and desert you...', 'info');
                this.log('üéµ Never gonna make you cry...', 'info');
                this.log('üéµ Never gonna say goodbye...', 'info');
                this.log('üéµ Never gonna tell a lie and hurt you...', 'info');
            }
            
            fortune() {
                const fortunes = [
                    "A beautiful, smart, and loving person will be coming into your life.",
                    "A dubious friend may be an enemy in camouflage.",
                    "A faithful friend is a strong defense.",
                    "A fresh start will put you on your way.",
                    "A golden egg of opportunity falls into your lap this month.",
                    "A lifetime friend shall soon be made.",
                    "A light heart carries you through all the hard times.",
                    "A new perspective will come with the new year.",
                    "A pleasant surprise is waiting for you.",
                    "A short pencil is usually better than a long memory any day."
                ];
                const fortune = fortunes[Math.floor(Math.random() * fortunes.length)];
                this.log(`üîÆ Fortune: ${fortune}`, 'info');
            }
            
            async matrix() {
                this.log('üåê Entering the Matrix...', 'info');
                for (let i = 0; i < 5; i++) {
                    await new Promise(resolve => setTimeout(resolve, 500));
                    this.log('01010101010101010101010101010101', 'output');
                }
                this.log('üåê Matrix mode activated!', 'success');
            }
            
            async hack() {
                this.log('üíª Hacker mode activated...', 'info');
                this.log('üîì Bypassing security protocols...', 'output');
                this.log('üîì Accessing mainframe...', 'output');
                this.log('üîì Downloading classified data...', 'output');
                this.log('‚úÖ Hack complete! You are now a l33t h4x0r!', 'success');
            }
            
            async disco() {
                this.log('üï∫ Disco mode activated!', 'info');
                this.log('üíÉ Stayin\' alive, stayin\' alive...', 'output');
                this.log('üéµ Ah, ha, ha, ha, stayin\' alive, stayin\' alive...', 'output');
                this.log('‚ú® Disco fever!', 'success');
            }
            
            sudoMine() {
                this.log('üîê Sudo access granted!', 'info');
                this.log('‚ö° Super user mining mode activated!', 'success');
                this.log('üöÄ Mining with admin privileges...', 'output');
                this.totalEarned += 0.1;
                this.log('üí∞ Admin bonus: +0.1 OMEGA', 'success');
            }

            async fundStressWallet(amount) {
                if (!this.signer) {
                    this.log('Please connect your wallet first using: connect', 'error');
                    return;
                }
                if (!this.stressWallet) {
                    this.log('No stress test wallet created. Run "stress" first to create a wallet.', 'error');
                    return;
                }
                if (!amount || isNaN(amount) || Number(amount) <= 0) {
                    this.log('Invalid amount. Usage: fund [amount]', 'error');
                    return;
                }
                try {
                    this.log(`üí∞ Funding stress test wallet with ${amount} OMEGA...`, 'info');
                    const tx = await this.signer.sendTransaction({
                        to: this.stressWallet.address,
                        value: this.ethers.utils.parseEther(amount),
                        gasLimit: 21000
                    });
                    this.log(`üì§ Funding transaction sent: ${tx.hash}`, 'info');
                    await tx.wait();
                    this.log(`‚úÖ Stress test wallet funded with ${amount} OMEGA!`, 'success');
                    this.log('üöÄ Stress test will automatically start once funding is detected...', 'info');
                } catch (error) {
                    this.log('‚ùå Failed to fund stress test wallet: ' + error.message, 'error');
                }
            }

            async setTheme(theme) {
                const validThemes = ['dark', 'light', 'matrix', 'retro'];
                if (!validThemes.includes(theme)) {
                    this.log('Invalid theme. Available: dark, light, matrix, retro', 'error');
                    return;
                }
                document.body.classList.remove('theme-dark', 'theme-light', 'theme-matrix', 'theme-retro');
                document.body.classList.add('theme-' + theme);
                localStorage.setItem('omega-terminal-theme', theme);
                this.log(`Theme set to ${theme}`, 'success');
            }

            toggleTheme() {
                this.isDarkTheme = !this.isDarkTheme;
                this.applyTheme();
                localStorage.setItem('omega-miner-theme', this.isDarkTheme ? 'dark' : 'light');
            }
            
            applyTheme() {
                const terminal = document.getElementById('terminal');
                const themeToggle = document.querySelector('.theme-toggle');
                
                if (this.isDarkTheme) {
                    terminal.classList.remove('light-theme');
                    themeToggle.textContent = '';
                } else {
                    terminal.classList.add('light-theme');
                    themeToggle.textContent = '';
                }
            }
        }
    </script>
    
    <!-- Initialize the terminal when DOM is ready -->
    <script>
        // Ensure the terminal initializes after DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing OmegaMinerTerminal...');
            try {
                window.terminal = new OmegaMinerTerminal();
                console.log('OmegaMinerTerminal initialized successfully');
            } catch (error) {
                console.error('Failed to initialize OmegaMinerTerminal:', error);
                // Fallback: try to show terminal even if initialization fails
                const bootAnimation = document.getElementById('bootAnimation');
                const terminal = document.getElementById('terminal');
                if (bootAnimation && terminal) {
                    bootAnimation.style.display = 'none';
                    terminal.style.display = 'flex';
                    console.log('Terminal shown with fallback initialization');
                }
            }
        });
        
        // Additional fallback for immediate execution if DOM is already loaded
        if (document.readyState === 'loading') {
            // DOM is still loading, the event listener above will handle it
        } else {
            // DOM is already loaded, initialize immediately
            console.log('DOM already loaded, initializing OmegaMinerTerminal immediately...');
            try {
                window.terminal = new OmegaMinerTerminal();
                console.log('OmegaMinerTerminal initialized successfully (immediate)');
            } catch (error) {
                console.error('Failed to initialize OmegaMinerTerminal (immediate):', error);
            }
        }
    </script>
</body>
</html>
