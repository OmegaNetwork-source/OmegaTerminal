<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' https: data: blob:; script-src 'self' 'unsafe-inline' 'unsafe-eval' https:; style-src 'self' 'unsafe-inline' https:; img-src 'self' data: https:; font-src 'self' https:; connect-src 'self' https:;">
    <title>Omega Terminal - Mining Interface</title>
    <script src="https://cdn.ethers.io/lib/ethers-5.7.2.umd.min.js" type="application/javascript"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #000;
            color: #ffffff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
            overflow: hidden;
        }

        .terminal {
            width: 100vw;
            height: 100vh;
            padding: 20px;
            background: linear-gradient(135deg, #000 0%, #111111 100%);
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .terminal-header {
            border-bottom: 1px solid #ffffff;
            padding-bottom: 10px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .terminal-title {
            font-size: 28px;
            font-weight: bold;
            text-shadow: 0 0 15px #ffffff, 0 0 30px #ffffff;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .terminal-status {
            font-size: 12px;
            color: #cccccc;
        }

        .theme-toggle {
            width: 22px;
            height: 22px;
            background: transparent;
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: pointer;
            margin-right: 0;
            margin-left: 0;
            display: inline-block;
            transition: border-color 0.2s;
            box-sizing: border-box;
            outline: none;
        }

        .theme-toggle:hover {
            border-color: #99ccff;
            background: rgba(255,255,255,0.05);
        }

        .terminal-input-section {
            border-top: 1px solid #ffffff;
            padding-top: 10px;
            margin-top: auto;
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #ffffff;
        }

        .terminal-content {
            flex: 1;
            overflow-y: auto;
            padding-right: 10px;
            margin-bottom: 20px;
            user-select: text !important;
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
        }

        .terminal-line {
            margin-bottom: 5px;
            word-wrap: break-word;
        }

        .prompt {
            color: #ffffff;
            font-weight: bold;
        }

        .command {
            color: #ffffff;
        }

        .output {
            color: #cccccc;
            margin-left: 20px;
            user-select: text !important;
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
        }

        .error {
            color: #ff6666;
        }

        .success {
            color: #ffffff;
        }

        .warning {
            color: #ffffcc;
        }

        .info {
            color: #99ccff;
        }

        .mining-status {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #ffffff;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #111111;
            border: 1px solid #ffffff;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffffff, #cccccc);
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px #ffffff;
        }

        .input-line {
            display: flex;
            align-items: center;
            background: transparent;
        }

        .input-prompt {
            color: #ffffff;
            font-weight: bold;
            margin-right: 10px;
            font-size: 16px;
        }

        .input-field {
            background: transparent;
            border: none;
            color: #ffffff;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            outline: none;
            flex: 1;
            padding: 5px;
        }

        .input-field::placeholder {
            color: #666666;
        }

        .cursor {
            animation: blink 1s infinite;
            color: #ffffff;
            font-size: 16px;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .mining-animation {
            display: inline-block;
            animation: mining-pulse 2s infinite;
        }

        @keyframes mining-pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }

        .stat-box {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #ffffff;
            padding: 10px;
            border-radius: 5px;
        }

        .stat-label {
            color: #cccccc;
            font-size: 12px;
        }

        .stat-value {
            color: #ffffff;
            font-size: 16px;
            font-weight: bold;
        }

        /* Boot Animation Styles */
        .boot-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            font-family: 'Courier New', monospace;
        }

        .omega-symbols {
            font-size: 48px;
            color: #ffffff;
            text-shadow: 0 0 20px #ffffff;
            margin-bottom: 20px;
            animation: omega-float 3s ease-in-out infinite;
        }

        .pickaxe {
            font-size: 36px;
            color: #ffcc00;
            text-shadow: 0 0 15px #ffcc00;
            animation: pickaxe-swing 2s ease-in-out infinite;
            margin-bottom: 30px;
        }

        .welcome-text {
            font-size: 24px;
            color: #ffffff;
            text-align: center;
            line-height: 1.5;
            text-shadow: 0 0 10px #ffffff;
        }

        .loading-dots {
            font-size: 18px;
            color: #cccccc;
            margin-top: 20px;
            animation: loading-pulse 1.5s ease-in-out infinite;
        }

        @keyframes omega-float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        @keyframes pickaxe-swing {
            0%, 100% { transform: rotate(-15deg); }
            50% { transform: rotate(15deg); }
        }

        @keyframes loading-pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        .hidden {
            display: none !important;
        }

        /* Light Theme Styles */
        .terminal.light-theme {
            background: linear-gradient(135deg, #f5f5f5 0%, #e0e0e0 100%);
            color: #000000;
        }

        .terminal.light-theme .terminal-header {
            border-bottom: 1px solid #000000;
        }

        .terminal.light-theme .terminal-title {
            color: #000000;
            text-shadow: 0 0 15px #000000, 0 0 30px #000000;
        }

        .terminal.light-theme .terminal-status {
            color: #333333;
        }

        .terminal.light-theme .theme-toggle {
            background: rgba(0, 0, 0, 0.1);
            border: 1px solid #000000;
            color: #000000;
        }

        .terminal.light-theme .theme-toggle:hover {
            background: rgba(0, 0, 0, 0.2);
        }

        .terminal.light-theme .terminal-input-section {
            border-top: 1px solid #000000;
            background: rgba(0, 0, 0, 0.05);
            border: 1px solid #000000;
        }

        .terminal.light-theme .prompt {
            color: #000000;
        }

        .terminal.light-theme .command {
            color: #000000;
        }

        .terminal.light-theme .output {
            color: #333333;
        }

        .terminal.light-theme .error {
            color: #cc0000;
        }

        .terminal.light-theme .success {
            color: #000000;
        }

        .terminal.light-theme .warning {
            color: #cc6600;
        }

        .terminal.light-theme .info {
            color: #0066cc;
        }

        .terminal.light-theme .input-prompt {
            color: #000000;
        }

        .terminal.light-theme .input-field {
            color: #000000;
        }

        .terminal.light-theme .input-field::placeholder {
            color: #666666;
        }

        .terminal.light-theme .cursor {
            color: #000000;
        }

        .terminal.light-theme .mining-status {
            background: rgba(0, 0, 0, 0.1);
            border: 1px solid #000000;
        }

        .terminal.light-theme .stat-box {
            background: rgba(0, 0, 0, 0.05);
            border: 1px solid #000000;
        }

        .terminal.light-theme .stat-label {
            color: #333333;
        }

        .terminal.light-theme .stat-value {
            color: #000000;
        }

        .output.error {
            color: #ff3333 !important;
            font-weight: bold !important;
        }

        /* --- FORCE RED AND BOLD FOR ERROR OUTPUT --- */
        .terminal-content .output.error,
        .output.error {
            color: #ff3333 !important;
            font-weight: bold !important;
        }

        .terminal-content, .output, .output.error, .output.success, .output.info, .output.warning,
        .terminal-content *, .output *, .output.error *, .output.success *, .output.info *, .output.warning * {
            user-select: text !important;
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
        }

        .terminal-line .copyable {
            cursor: pointer;
            text-decoration: underline;
            color: #00ff00;
            transition: all 0.3s ease;
        }
        
        .terminal-line .copyable:hover {
            color: #ffff00;
            text-shadow: 0 0 10px #ffff00;
        }
        
        .terminal-line .copyable:active {
            color: #ff0000;
        }

        body.theme-dark {
            background: #000;
            color: #fff;
        }
        body.theme-light {
            background: #fff;
            color: #111;
        }
        body.theme-matrix {
            background: #000;
            color: #00ff00;
        }
        body.theme-retro {
            background: #111;
            color: #39ff14;
        }
        .theme-matrix .terminal-header, .theme-retro .terminal-header {
            border-bottom: 1px solid #00ff00;
        }
        .theme-matrix .input-prompt, .theme-retro .input-prompt {
            color: #39ff14;
        }
        .theme-retro .input-prompt {
            color: orange;
        }

        /* Matrix Theme Styles */
        body.theme-matrix {
            background: #000 !important;
            color: #00ff00 !important;
        }
        body.theme-matrix .terminal {
            background: #000 !important;
            color: #00ff00 !important;
        }
        body.theme-matrix .terminal-header {
            border-bottom: 1px solid #00ff00 !important;
        }
        body.theme-matrix .prompt,
        body.theme-matrix .input-prompt {
            color: #00ff00 !important;
            font-weight: bold;
        }
        body.theme-matrix .command {
            color: #00ff00 !important;
        }
        body.theme-matrix .output {
            color: #00ff00 !important;
        }
        body.theme-matrix .error {
            color: #ff3333 !important;
        }
        body.theme-matrix .success {
            color: #00ff00 !important;
        }
        body.theme-matrix .warning {
            color: #ffff00 !important;
        }
        body.theme-matrix .info {
            color: #00ffff !important;
        }

        /* Retro Theme Styles */
        body.theme-retro {
            background: #181200 !important;
            color: #39ff14 !important;
        }
        body.theme-retro .terminal {
            background: #181200 !important;
            color: #39ff14 !important;
        }
        body.theme-retro .terminal-header {
            border-bottom: 1px solid #ffaa00 !important;
        }
        body.theme-retro .prompt,
        body.theme-retro .input-prompt {
            color: #ffaa00 !important;
            font-weight: bold;
        }
        body.theme-retro .command {
            color: #39ff14 !important;
        }
        body.theme-retro .output {
            color: #39ff14 !important;
        }
        body.theme-retro .error {
            color: #ff3333 !important;
        }
        body.theme-retro .success {
            color: #ffaa00 !important;
        }
        body.theme-retro .warning {
            color: #ffff00 !important;
        }
        body.theme-retro .info {
            color: #00ffff !important;
        }
    </style>
</head>
<body>
    <!-- Boot Animation -->
    <div class="boot-animation" id="bootAnimation">
        <div class="omega-symbols">Ω Ω Ω Ω Ω</div>
        <div class="pickaxe">⛏️</div>
        <div class="welcome-text">
            Welcome to Omega Terminal v1<br>
            <span style="font-size: 16px; color: #cccccc;">Type below to get started</span>
        </div>
        <div class="loading-dots">Loading...</div>
    </div>

    <div class="terminal" id="terminal" style="display: none;">
        <div class="terminal-header">
            <div class="terminal-title">Omega Terminal v1.0.2</div>
            <div style="display: flex; align-items: center; gap: 18px; margin-left: auto;">
                <button class="theme-toggle" title="Toggle Theme"></button>
                <div class="terminal-status" id="connectionStatus">DISCONNECTED</div>
            </div>
        </div>
        
        <!-- Faucet Info Box -->
        <div id="faucetInfoBox" style="background: rgba(0, 153, 255, 0.10); border: 1px solid #99ccff; color: #99ccff; padding: 10px 16px; border-radius: 6px; margin: 0 0 12px 0; font-size: 15px;">
            <b>Note:</b> Each wallet can only claim from the faucet once every 24 hours.<br>
            If you try to claim again before the cooldown is over, the transaction will fail.
        </div>
        <div class="terminal-content" id="terminalContent">
            <div class="terminal-line">
                <span class="prompt">root@omega-miner:~$</span>
                <span class="command"> ./omega-miner --version</span>
            </div>
            <div class="output">Omega Mining Terminal v1.0.0</div>
            <div class="output">Connected to Omega Network (Chain ID: 1313161768)</div>
            <div class="output">Mining Contract: <span id="contractAddress">Not deployed</span></div>
            <div class="terminal-line">
                <span class="prompt">root@omega-miner:~$</span>
                <span class="command"> ./omega-miner --help</span>
            </div>
            <div class="output error">Type 'help' to see a list of commands</div>
        </div>

        <div class="terminal-input-section">
            <div class="input-line">
                <span class="input-prompt">root@omega-miner:~$</span>
                <input type="text" class="input-field" id="commandInput" placeholder="Enter command..." autocomplete="off">
                <span class="cursor">|</span>
            </div>
        </div>
    </div>

    <script>
        // Simplified ethers loading with fallback support
        function loadEthers() {
            return new Promise((resolve, reject) => {
                // Small delay to ensure CDN script has time to load
                setTimeout(() => {
                    console.log('Checking for ethers availability...');
                    
                    // Check if ethers is already loaded (CDN success)
                    if (typeof ethers !== 'undefined') {
                        console.log('Ethers loaded successfully from CDN');
                        resolve(ethers);
                        return;
                    }
                    
                    console.log('CDN ethers not loaded, trying additional CDN sources...');
                    
                    // Try multiple CDN sources
                    const cdnSources = [
                        'https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js',
                        'https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js'
                    ];
                    
                    let currentSource = 0;
                    
                    function tryNextSource() {
                        if (currentSource >= cdnSources.length) {
                            // All CDN sources failed, load fallback
                            console.log('All CDN sources failed, loading fallback ethers...');
                            loadEthersFallback();
                            resolve(ethers);
                            return;
                        }
                        
                        const script = document.createElement('script');
                        script.src = cdnSources[currentSource];
                        script.onload = () => {
                            if (typeof ethers !== 'undefined') {
                                console.log(`Ethers loaded successfully from: ${cdnSources[currentSource]}`);
                                resolve(ethers);
                            } else {
                                currentSource++;
                                tryNextSource();
                            }
                        };
                        script.onerror = () => {
                            console.warn(`Failed to load ethers from: ${cdnSources[currentSource]}`);
                            currentSource++;
                            tryNextSource();
                        };
                        document.head.appendChild(script);
                    }
                    
                    tryNextSource();
                }, 500); // 500ms delay to ensure CDN script has time to load
            });
        }

        // Fallback ethers implementation - only loads if all CDN sources fail
        function loadEthersFallback() {
            console.log('Loading ethers fallback...');
            window.ethers = {
                providers: {
                    Web3Provider: function(provider) {
                        this.provider = provider;
                        this.getSigner = () => ({ 
                            getAddress: () => Promise.resolve('0x0000000000000000000000000000000000000000'),
                            sendTransaction: () => Promise.reject(new Error('Fallback ethers - no real transactions'))
                        });
                        this.getGasPrice = () => Promise.resolve({ toString: () => '20000000000' });
                        this.getBalance = () => Promise.resolve({ isZero: () => true });
                        this.getTransactionCount = () => Promise.resolve(0);
                    }
                },
                Contract: function(address, abi, signer) {
                    this.address = address;
                    this.abi = abi;
                    this.signer = signer;
                    // Add basic contract methods
                    this.startMining = () => Promise.resolve({ wait: () => Promise.resolve() });
                    this.claimRewards = () => Promise.resolve({ wait: () => Promise.resolve() });
                },
                Wallet: {
                    createRandom: function() {
                        return {
                            address: '0x' + Math.random().toString(16).substr(2, 40),
                            privateKey: '0x' + Math.random().toString(16).substr(2, 64),
                            connect: function(provider) { return this; },
                            sendTransaction: function(tx) { 
                                return Promise.resolve({ 
                                    hash: '0x' + Math.random().toString(16).substr(2, 64),
                                    wait: () => Promise.resolve()
                                }); 
                            }
                        };
                    }
                },
                utils: {
                    formatEther: (wei) => (parseInt(wei) / 1e18).toString(),
                    parseEther: (ether) => (parseFloat(ether) * 1e18).toString(),
                    id: (text) => '0x' + Math.random().toString(16).substr(2, 64),
                    defaultAbiCoder: {
                        decode: () => ['0x0000000000000000000000000000000000000000', '1000000000000000000', '1']
                    },
                    hexDataSlice: (data, start) => data
                }
            };
            console.log('Ethers fallback loaded successfully');
        }

        class OmegaMinerTerminal {
            constructor() {
                this.provider = null;
                this.signer = null;
                this.contract = null;
                this.isMining = false;
                this.miningInterval = null;
                this.currentNonce = 0;
                this.ethers = null;
                this.isDarkTheme = true; // Default to dark theme
                
                // New mining system properties
                this.pendingClaimableBalance = 0;
                this.totalEarned = 0; // Track total earned during session
                this.waitingForContinueResponse = false;
                
                // Stress test properties
                this.isStressTesting = false;
                this.stressTestInterval = null;
                this.stressTestStats = {
                    walletsCreated: 0,
                    transactionsSent: 0,
                    successfulTxs: 0,
                    failedTxs: 0,
                    startTime: 0
                };
                this.stressWallet = null;
                this.stressNonce = 0;
                
                // Contract properties
                this.contractAddress = "0x54c731627f2d2b55267b53e604c869ab8e6a323b"; // SimpleMiner contract with claimTo
                this.faucetAddress = "0x0d4a5d6d28ce3d79dfd145b3ca5286a50c2f9895"; // Keep existing faucet
                this.minerFaucetAddress = '0x1c4ffffcc804ba265f6cfccffb94d0ae28b36207'; // Deployed OmegaMinerFaucet contract
                this.contractABI = [
                    "function mineBlock(uint256 nonce, bytes32 solution) external",
                    "function claimRewards() external",
                    "function claimTo(address recipient) external",
                    "function getMinerInfo(address miner) external view returns (uint256 _totalMined, uint256 _lastMineTime, uint256 _pendingRewards)",
                    "function calculateReward(address miner, uint256 nonce, bytes32 solution) external view returns (uint256)",
                    "function cooldownPeriod() external view returns (uint256)",
                    "function totalRewardsDistributed() external view returns (uint256)",
                    "function owner() external view returns (address)",
                    "function setCooldownPeriod(uint256 _cooldown) external",
                    "function withdrawExcess() external",
                    "event BlockMined(address indexed miner, uint256 nonce, bytes32 solution, uint256 reward)",
                    "event RewardsClaimed(address indexed miner, uint256 amount)"
                ];
                this.faucetABI = [
                    {
                        "inputs": [],
                        "name": "claim",
                        "outputs": [],
                        "stateMutability": "nonpayable",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "emergencyWithdraw",
                        "outputs": [],
                        "stateMutability": "nonpayable",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "stateMutability": "nonpayable",
                        "type": "constructor"
                    },
                    {
                        "anonymous": false,
                        "inputs": [
                            {
                                "indexed": false,
                                "internalType": "uint256",
                                "name": "amount",
                                "type": "uint256"
                            }
                        ],
                        "name": "FaucetRefilled",
                        "type": "event"
                    },
                    {
                        "inputs": [],
                        "name": "refillFaucet",
                        "outputs": [],
                        "stateMutability": "payable",
                        "type": "function"
                    },
                    {
                        "anonymous": false,
                        "inputs": [
                            {
                                "indexed": true,
                                "internalType": "address",
                                "name": "user",
                                "type": "address"
                            },
                            {
                                "indexed": false,
                                "internalType": "uint256",
                                "name": "amount",
                                "type": "uint256"
                            },
                            {
                                "indexed": false,
                                "internalType": "uint256",
                                "name": "timestamp",
                                "type": "uint256"
                            }
                        ],
                        "name": "TokensClaimed",
                        "type": "event"
                    },
                    {
                        "inputs": [],
                        "name": "withdrawFaucet",
                        "outputs": [],
                        "stateMutability": "nonpayable",
                        "type": "function"
                    },
                    {
                        "stateMutability": "payable",
                        "type": "receive"
                    },
                    {
                        "inputs": [
                            {
                                "internalType": "address",
                                "name": "user",
                                "type": "address"
                            }
                        ],
                        "name": "canClaim",
                        "outputs": [
                            {
                                "internalType": "bool",
                                "name": "",
                                "type": "bool"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "CLAIM_AMOUNT",
                        "outputs": [
                            {
                                "internalType": "uint256",
                                "name": "",
                                "type": "uint256"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "CLAIM_COOLDOWN",
                        "outputs": [
                            {
                                "internalType": "uint256",
                                "name": "",
                                "type": "uint256"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "faucetBalance",
                        "outputs": [
                            {
                                "internalType": "uint256",
                                "name": "",
                                "type": "uint256"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [
                            {
                                "internalType": "address",
                                "name": "user",
                                "type": "address"
                            }
                        ],
                        "name": "getClaimInfo",
                        "outputs": [
                            {
                                "internalType": "bool",
                                "name": "canClaimNow",
                                "type": "bool"
                            },
                            {
                                "internalType": "uint256",
                                "name": "lastClaim",
                                "type": "uint256"
                            },
                            {
                                "internalType": "uint256",
                                "name": "timeUntilNextClaim",
                                "type": "uint256"
                            },
                            {
                                "internalType": "uint256",
                                "name": "claimAmount",
                                "type": "uint256"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "getFaucetBalance",
                        "outputs": [
                            {
                                "internalType": "uint256",
                                "name": "",
                                "type": "uint256"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [
                            {
                                "internalType": "address",
                                "name": "user",
                                "type": "address"
                            }
                        ],
                        "name": "getTimeUntilNextClaim",
                        "outputs": [
                            {
                                "internalType": "uint256",
                                "name": "",
                                "type": "uint256"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [
                            {
                                "internalType": "address",
                                "name": "",
                                "type": "address"
                            }
                        ],
                        "name": "lastClaimTime",
                        "outputs": [
                            {
                                "internalType": "uint256",
                                "name": "",
                                "type": "uint256"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "totalClaims",
                        "outputs": [
                            {
                                "internalType": "uint256",
                                "name": "",
                                "type": "uint256"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    }
                ];
                this.minerFaucetABI = [
                    {
                        "inputs": [],
                        "name": "mine",
                        "outputs": [],
                        "stateMutability": "payable",
                        "type": "function"
                    },
                    {
                        "inputs": [{"internalType": "address", "name": "", "type": "address"}],
                        "name": "totalMined",
                        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [{"internalType": "address", "name": "", "type": "address"}],
                        "name": "lastMineTime",
                        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                        "stateMutability": "view",
                        "type": "function"
                    }
                ];
                
                this.loadTheme();
                this.init();
            }
            
            async init() {
                console.log('OmegaMinerTerminal initializing...');
                // Show boot animation first
                await this.showBootAnimation();
                // Always set up event listeners immediately after boot
                this.setupEventListeners();
                try {
                    console.log('Loading ethers library...');
                    this.ethers = await loadEthers();
                    console.log('Ethers library loaded successfully');
                    this.log('Ethers library loaded successfully', 'success');
                    this.checkWalletConnection();
                } catch (error) {
                    console.error('Failed to load ethers:', error);
                    this.log('Failed to load ethers library: ' + error.message, 'error');
                    this.log('Please check your internet connection and refresh the page', 'error');
                }
            }
            
            loadTheme() {
                const theme = localStorage.getItem('omega-terminal-theme') || 'dark';
                document.body.classList.remove('theme-dark', 'theme-light', 'theme-matrix', 'theme-retro');
                document.body.classList.add('theme-' + theme);
            }
            
            async showBootAnimation() {
                console.log('Showing boot animation...');
                return new Promise((resolve) => {
                    setTimeout(() => {
                        console.log('Hiding boot animation, showing terminal...');
                        // Hide boot animation and show terminal
                        document.getElementById('bootAnimation').style.display = 'none';
                        document.getElementById('terminal').style.display = 'flex';
                        
                        // Apply theme after terminal is shown
                        this.applyTheme();
                        
                        console.log('Terminal ready!');
                        resolve();
                    }, 3000); // Show animation for 3 seconds
                });
            }
            
            setupEventListeners() {
                const input = document.getElementById('commandInput');
                if (input) {
                    input.focus();
                    // Bind the event handler to the class instance
                    const boundExecuteCommand = this.executeCommand.bind(this);
                    input.addEventListener('keypress', function(e) {
                        if (e.key === 'Enter') {
                            boundExecuteCommand(input.value);
                            input.value = '';
                        }
                        // Ctrl+C to stop stress test
                        if (e.key === 'c' && e.ctrlKey) {
                            // 'this' is not needed here, as isStressTesting is not used in this context
                        }
                    });
                    // Fallback: refocus input if user clicks anywhere in the terminal
                    document.getElementById('terminal').addEventListener('click', function() {
                        input.focus();
                    });
                }
                // Setup theme toggle
                const themeToggle = document.querySelector('.theme-toggle');
                if (themeToggle) {
                    themeToggle.addEventListener('click', () => {
                        this.toggleTheme();
                    });
                    // Remove emoji/text, just hollow circle
                    themeToggle.textContent = '';
                }
            }
            
            async checkWalletConnection() {
                if (typeof window.ethereum !== 'undefined') {
                    try {
                        const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                        if (accounts.length > 0) {
                            await this.connectWallet();
                        }
                    } catch (error) {
                        this.log('Error checking wallet connection: ' + error.message, 'error');
                    }
                }
            }
            
            async connectWallet() {
                try {
                    if (!this.ethers) {
                        this.log('Ethers library not loaded. Please refresh the page.', 'error');
                        return;
                    }

                    if (typeof window.ethereum === 'undefined') {
                        this.log('MetaMask not found. Please install MetaMask.', 'error');
                        return;
                    }
                    
                    this.log('🔗 Connecting to MetaMask...', 'info');
                    
                    // Request account access
                    try {
                        await window.ethereum.request({ method: 'eth_requestAccounts' });
                        this.log('✅ MetaMask account access granted', 'success');
                    } catch (requestError) {
                        this.log('❌ MetaMask connection denied by user', 'error');
                        return;
                    }
                    
                    this.provider = new this.ethers.providers.Web3Provider(window.ethereum);
                    this.signer = this.provider.getSigner();
                    
                    this.log('🔍 Getting wallet address...', 'info');
                    const address = await this.signer.getAddress();
                    
                    // Check if we're using fallback ethers (which would return 0x000... address)
                    if (address === '0x0000000000000000000000000000000000000000') {
                        this.log('⚠️ Using fallback ethers - real transactions not available', 'warning');
                        this.log('💡 Please check your internet connection and refresh the page', 'info');
                        return;
                    }
                    
                    this.log(`✅ Wallet connected: ${address}`, 'success');
                    this.updateConnectionStatus('CONNECTED');
                    
                    if (this.contractAddress !== '0x0000000000000000000000000000000000000000') {
                        this.contract = new this.ethers.Contract(this.contractAddress, this.contractABI, this.signer);
                        this.log('✅ Mining contract connected', 'success');
                    }
                    
                } catch (error) {
                    console.error('Connect wallet error:', error);
                    this.log('❌ Failed to connect wallet: ' + error.message, 'error');
                    this.log('💡 Make sure MetaMask is unlocked and you approve the connection', 'info');
                }
            }
            
            async disconnectWallet() {
                try {
                    if (!this.signer) {
                        this.log('No wallet connected to disconnect.', 'warning');
                        return;
                    }
                    
                    // Get the address before disconnecting for the message
                    const address = await this.signer.getAddress();
                    
                    // Clear all wallet-related properties
                    this.provider = null;
                    this.signer = null;
                    this.contract = null;
                    this.pendingClaimableBalance = 0;
                    
                    this.log(`🔌 Wallet disconnected: ${address}`, 'success');
                    this.updateConnectionStatus('DISCONNECTED');
                    this.log('💡 Use "connect" command to reconnect your wallet', 'info');
                    
                } catch (error) {
                    console.error('Disconnect wallet error:', error);
                    this.log('❌ Error disconnecting wallet: ' + error.message, 'error');
                }
            }
            
            async executeCommand(command) {
                // Hide faucet info box after first command
                try {
                    const infoBox = document.getElementById('faucetInfoBox');
                    if (infoBox && infoBox.style.display !== 'none') {
                        infoBox.style.display = 'none';
                    }
                } catch (e) {}
                const args = command.trim().split(/\s+/);
                const cmd = args[0].toLowerCase();
                this.logCommand(command);
                // Handle continue mining response
                if (this.waitingForContinueResponse) {
                    this.waitingForContinueResponse = false;
                    if (cmd === 'yes' || cmd === 'y') {
                        this.log('✅ Continuing mining...', 'success');
                        await this.startMiningStressTest();
                        return;
                    } else {
                        this.log('👋 Mining session ended. Thanks for mining!', 'info');
                        return;
                    }
                }
                switch (cmd) {
                    case 'connect':
                        await this.connectWallet();
                        break;
                    case 'disconnect':
                        await this.disconnectWallet();
                        break;
                    case 'mine':
                        await this.mine();
                        break;
                    case 'session':
                        await this.startMiningSession();
                        break;
                    case 'faucet':
                        await this.faucetClaim();
                        break;
                    case 'claim':
                        await this.claim();
                        break;
                    case 'pending':
                        await this.showPendingRewards();
                        break;
                    case 'balance':
                        await this.showBalance();
                        break;
                    case 'stop':
                        this.stopAll();
                        break;
                    case 'status':
                        await this.showStatus();
                        break;
                    case 'stats':
                        await this.showStats();
                        break;
                    case 'deposit':
                        await this.depositForMining();
                        break;
                    case 'deploy':
                        await this.deployContract();
                        break;
                    case 'contract':
                        await this.showContractInfo();
                        break;
                    case 'stress':
                        await this.startStressTest();
                        break;
                    case 'stopstress':
                        this.stopStressTest();
                        break;
                    case 'stressstats':
                        this.showStressStats();
                        break;
                    case 'theme':
                        if (args.length >= 2) {
                            await this.setTheme(args[1]);
                        } else {
                            this.toggleTheme();
                        }
                        break;
                    case 'help':
                        this.showHelp();
                        break;
                    case 'clear':
                        this.clearTerminal();
                        break;
                    case 'rickroll':
                        await this.rickroll();
                        break;
                    case 'fortune':
                        this.fortune();
                        break;
                    case 'matrix':
                        await this.matrix();
                        break;
                    case 'hack':
                        await this.hack();
                        break;
                    case 'disco':
                        await this.disco();
                        break;
                    case 'sudo mine':
                        this.sudoMine();
                        break;
                    case 'minestats':
                        await this.showMiningStats();
                        break;
                    case 'send':
                        await this.sendOmega(command);
                        break;
                    case 'fund':
                        if (args.length >= 2) {
                            if (this.isStressTesting && this.stressWallet) {
                                await this.fundStressWallet(args[1]);
                            } else {
                                await this.fundMiningWallet(args[1]);
                            }
                        } else {
                            this.log('Usage: fund <amount>', 'error');
                        }
                        break;
                    case 'fundmining':
                        if (args.length >= 2) {
                            await this.fundMiningWallet(args[1]);
                        } else {
                            this.log('Usage: fundmining [amount]', 'error');
                        }
                        break;
                    case 'clob':
                        this.log('Olympus cDEX Launching Soon', 'info');
                        break;
                    case 'v2':
                        this.log('V2 will be a significant upgrade with bot trading, AI, and other surprises. Coming Soon', 'info');
                        break;
                    default:
                        if (cmd) {
                            this.log(`Command not found: ${command}`, 'error');
                            this.log('Type "help" for available commands', 'info');
                        }
                }
            }
            
            async mine() {
                if (!this.signer) {
                    this.log('Please connect your wallet first using: connect', 'error');
                    return;
                }

                if (!this.contract) {
                    this.log('Mining contract not connected. Please check your connection.', 'error');
                    return;
                }

                if (this.isMining) {
                    this.log('Mining is already in progress. Use "stop" to stop mining.', 'error');
                    return;
                }

                // Generate a new mining wallet (if not already generated)
                if (!this.miningWallet) {
                    this.miningWallet = this.ethers.Wallet.createRandom();
                    this.log('Fund Omega Rig For Mining', 'info');
                    this.logHtml(`Address: <span class="copyable" onclick="navigator.clipboard.writeText('${this.miningWallet.address}').then(() => window.terminal.log('✅ Address copied to clipboard!', 'success')).catch(() => window.terminal.log('❌ Failed to copy address', 'error'))">${this.miningWallet.address}</span>`, 'output');
                    this.miningWallet = this.miningWallet.connect(this.provider);
                }

                this.isMining = true;
                this.mineCount = 0;
                this.totalEarned = 0;
                this.startTime = Date.now();
                this.ghostTransactionCount = 0;

                this.log('🚀 Welcome To Omega Terminal v1.1.1!', 'success');
                this.log('⛏️  Automated Mining Mode Activated! Mining wallet will send all transactions.', 'info');
                this.log('💰 Average Reward: 0.0001 OMEGA | Max Reward: 1.0 OMEGA', 'info');
                this.logHtml('Waiting for mining wallet to be funded with OMEGA for gas...<br>💡 You need to fund your mining wallet with at least 0.002 OMEGA <span class="fund-link" style="color:#00ff99;cursor:pointer;text-decoration:underline;" onclick="window.terminal.fundMiningWallet(\'0.002\')">[Click here to fund]</span>', 'info');

                // Wait for funding before starting mining
                const minGas = this.ethers.utils.parseEther('0.002'); // Lowered for easier testing
                const checkAndStartMining = async () => {
                    if (!this.isMining) return;
                    const balance = await this.provider.getBalance(this.miningWallet.address);
                    if (balance.gte(minGas)) {
                        this.log('✅ Mining wallet funded! Starting mining...', 'success');
                        this.log('⛏️  Entering mining loop...', 'info'); // Added debug log
                        // Fetch and store the starting nonce
                        this.miningNonce = await this.provider.getTransactionCount(this.miningWallet.address, 'latest');
                        this.startAutomatedMiningLoop();
                    } else {
                        setTimeout(checkAndStartMining, 5000);
                    }
                };
                checkAndStartMining();
            }
            
            async startAutomatedMiningLoop() {
                const mineNextBlock = async () => {
                    if (!this.isMining) return;

                    try {
                        this.mineCount++;
                        const nonce = this.miningNonce;
                        this.miningNonce++;
                        const solution = this.generateRandomSolution();
                        this.log(`⛏️  Mining block #${this.mineCount}...`, 'info');
                        this.log(`🎯 Nonce: ${nonce}`, 'output');
                        // --- Begin hashing animation ---
                        const spinnerFrames = ['|', '/', '-', '\\'];
                        let spinnerIndex = 0;
                        for (let i = 0; i < 10; i++) {
                            await new Promise(resolve => setTimeout(resolve, 80));
                            this.log(`🔒 [${spinnerFrames[spinnerIndex]}] Hashing: ${this.generateFakeHash()}`, 'output');
                            spinnerIndex = (spinnerIndex + 1) % spinnerFrames.length;
                        }
                        // --- End hashing animation ---
                        this.log(`🔑 Solution: ${solution.slice(0, 16)}...`, 'output');
                        const tx = await this.contract.connect(this.miningWallet).mineBlock(nonce, solution, {
                            gasLimit: 200000,
                            gasPrice: await this.provider.getGasPrice()
                        });
                        this.logHtml(`📤 Transaction sent: <span class="copyable" onclick="navigator.clipboard.writeText('${tx.hash}').then(() => window.terminal.log('✅ Transaction hash copied to clipboard!', 'success')).catch(() => window.terminal.log('❌ Failed to copy transaction hash', 'error'))">${tx.hash}</span>`, 'info');
                        const receipt = await tx.wait();
                        if (receipt.status === 1) {
                            try {
                                const minerInfo = await this.contract.getMinerInfo(this.miningWallet.address);
                                const pendingRewards = minerInfo[2];
                                const rewardInWei = pendingRewards;
                                const rewardInEther = this.ethers.utils.formatEther(rewardInWei);
                                if (rewardInWei.gt(0)) {
                                    this.totalEarned += parseFloat(rewardInEther);
                                    this.log(`💰 Mining reward: +${rewardInEther} OMEGA`, 'success');
                                    this.log(`💳 Total earned this session: ${this.totalEarned.toFixed(6)} OMEGA`, 'info');
                                } else {
                                    this.log(`⛏️  Block mined (no reward this time)`, 'output');
                                }
                            } catch (error) {
                                this.log(`⚠️ Could not fetch reward info: ${error.message}`, 'warning');
                                const simulatedReward = this.calculateMiningReward();
                                if (simulatedReward > 0) {
                                    this.totalEarned += simulatedReward;
                                    this.log(`💰 Mining reward: +${simulatedReward.toFixed(6)} OMEGA (simulated)`, 'success');
                                    this.log(`💳 Total earned this session: ${this.totalEarned.toFixed(6)} OMEGA`, 'info');
                                } else {
                                    this.log(`⛏️  Block mined (no reward this time)`, 'output');
                                }
                            }
                        } else {
                            this.log(`❌ Mining transaction failed`, 'error');
                        }
                    } catch (error) {
                        this.log(`❌ Mining failed: ${error.message}`, 'error');
                        if (error.message && (error.message.includes('nonce') || error.message.includes('replacement'))) {
                            this.log('🔄 Nonce error detected, re-syncing nonce from network...', 'warning');
                            this.miningNonce = await this.provider.getTransactionCount(this.miningWallet.address, 'latest');
                        }
                    }
                    if (this.isMining) setTimeout(mineNextBlock, 15000);
                };
                mineNextBlock();
            }
            
            generateRandomSolution() {
                const chars = '0123456789abcdef';
                let solution = '0x';
                for (let i = 0; i < 64; i++) {
                    solution += chars[Math.floor(Math.random() * chars.length)];
                }
                return solution;
            }
            
            calculateMiningReward() {
                const random = Math.random();
                
                // 0.1% chance for max reward (1.0 OMEGA)
                if (random < 0.001) {
                    return 1.0;
                }
                // 1% chance for medium reward (0.01 OMEGA)
                else if (random < 0.01) {
                    return 0.01;
                }
                // 10% chance for small reward (0.001 OMEGA)
                else if (random < 0.1) {
                    return 0.001;
                }
                // 30% chance for tiny reward (0.0001 OMEGA)
                else if (random < 0.3) {
                    return 0.0001;
                }
                // 60% chance for no reward
                else {
                    return 0;
                }
            }
            
            generateFakeHash() {
                const chars = '0123456789abcdef';
                let hash = '0x';
                for (let i = 0; i < 64; i++) {
                    hash += chars[Math.floor(Math.random() * chars.length)];
                }
                return hash;
            }
            
            // Add missing methods that are referenced in the code
            logCommand(command) {
                const terminalContent = document.getElementById('terminalContent');
                const line = document.createElement('div');
                line.className = 'terminal-line';
                line.innerHTML = `<span class="prompt">root@omega-miner:~$</span><span class="command"> ${command}</span>`;
                terminalContent.appendChild(line);
                terminalContent.scrollTop = terminalContent.scrollHeight;
            }
            
            log(message, type = 'output') {
                const terminalContent = document.getElementById('terminalContent');
                const line = document.createElement('div');
                line.className = `output ${type}`;
                line.textContent = message;
                terminalContent.appendChild(line);
                terminalContent.scrollTop = terminalContent.scrollHeight;
            }
            
            logHtml(html, type = 'output') {
                const terminalContent = document.getElementById('terminalContent');
                const line = document.createElement('div');
                line.className = `terminal-line ${type}`;
                line.innerHTML = html;
                terminalContent.appendChild(line);
                terminalContent.scrollTop = terminalContent.scrollHeight;
            }
            
            clearTerminal() {
                const terminalContent = document.getElementById('terminalContent');
                terminalContent.innerHTML = '';
            }
            
            updateConnectionStatus(status) {
                const statusElement = document.getElementById('connectionStatus');
                if (statusElement) {
                    statusElement.textContent = status;
                }
            }
            
            showHelp() {
                this.log('=== Available Commands ===', 'info');
                this.log('Connect:      [connect] | Disconnect: [disconnect]', 'output');
                this.log('Theme:        [theme dark] [theme light] [theme matrix] [theme retro]', 'output');
                this.log('Mine:         [mine] - Start mining with a funded mining wallet', 'output');
                this.log('Faucet:       [faucet] | Balance: [balance]', 'output');
                this.log('Status:       [status] | Stats: [stats]', 'output');
                this.log('Send:         [send <address> <amount>]', 'output');
                this.log('Stress Test:  [stress] | Stop Stress: [stopstress] | Stress Stats: [stressstats]', 'output');
                this.log('Clear:        [clear] | Help: [help]', 'output');
                this.log('Fun:          [rickroll] [fortune] [matrix] [hack] [disco] [sudo mine]', 'output');
                this.log('---', 'output');
                this.log('Mining wallet is generated in-browser. Fund it from MetaMask, mine, then use [claim] to send rewards directly to your wallet.', 'info');
                this.log('CLOB: [clob]', 'output');
                this.log('V2: [v2]', 'output');
            }
            
            async showBalance() {
                if (!this.signer) {
                    this.log('Please connect your wallet first using: connect', 'error');
                    return;
                }
                try {
                    const address = await this.signer.getAddress();
                    const balance = await this.provider.getBalance(address);
                    const formattedBalance = this.ethers.utils.formatEther(balance);
                    this.log(`💰 Connected Wallet Balance: ${formattedBalance} OMEGA`, 'success');
                    this.log(`📍 Connected Wallet Address: ${address}`, 'info');
                    if (this.miningWallet) {
                        const minerInfo = await this.contract.getMinerInfo(this.miningWallet.address);
                        const pendingRewards = this.ethers.utils.formatEther(minerInfo[2]);
                        this.log(`⛏️ Mining Wallet: ${this.miningWallet.address}`, 'info');
                        this.log(`💳 Pending Mining Rewards: ${pendingRewards} OMEGA`, 'info');
                    }
                } catch (error) {
                    this.log('❌ Failed to get balance: ' + error.message, 'error');
                }
            }
            
            async showStatus() {
                if (!this.signer) {
                    this.log('❌ Wallet not connected', 'error');
                    return;
                }
                
                try {
                    const address = await this.signer.getAddress();
                    this.log(`✅ Wallet: ${address}`, 'success');
                    this.log(`⛏️  Mining: ${this.isMining ? 'Active' : 'Inactive'}`, 'info');
                    this.log(`💰 Pending: ${this.totalEarned.toFixed(6)} OMEGA`, 'info');
                    this.log(`📊 Blocks Mined: ${this.mineCount || 0}`, 'info');
                } catch (error) {
                    this.log('❌ Failed to get status: ' + error.message, 'error');
                }
            }
            
            async showStats() {
                this.log('📊 Mining Statistics:', 'info');
                this.log(`⛏️  Total Blocks: ${this.mineCount || 0}`, 'output');
                this.log(`👻 Ghost Transactions: ${this.ghostTransactionCount || 0}`, 'output');
                this.log(`💰 Total Earned: ${this.totalEarned.toFixed(6)} OMEGA`, 'output');
                this.log(`⏱️  Session Time: ${this.startTime ? Math.floor((Date.now() - this.startTime) / 1000) : 0}s`, 'output');
                this.log(`🎯 Reward Structure: Avg 0.0001 | Max 1.0 OMEGA`, 'output');
            }
            
            stopAll() {
                let stoppedActivities = [];
                
                // Stop mining
                if (this.isMining) {
                    this.isMining = false;
                    if (this.miningInterval) {
                        clearInterval(this.miningInterval);
                        this.miningInterval = null;
                    }
                    stoppedActivities.push('mining');
                }
                
                // Stop stress testing
                if (this.isStressTesting) {
                    this.isStressTesting = false;
                    if (this.stressTestInterval) {
                        clearInterval(this.stressTestInterval);
                        this.stressTestInterval = null;
                    }
                    stoppedActivities.push('stress testing');
                }
                
                if (stoppedActivities.length > 0) {
                    this.log(`⏹️  Stopped: ${stoppedActivities.join(', ')}`, 'success');
                } else {
                    this.log('⏹️  No activities were running to stop', 'info');
                }
            }
            
            async startMiningSession() {
                this.log('🚀 Starting mining session...', 'info');
                await this.mine();
            }
            
            async faucetClaim() {
                if (!this.signer) {
                    this.log('Please connect your wallet first using: connect', 'error');
                    return;
                }
                
                try {
                    this.log('🚰 Claiming from faucet...', 'info');
                    const faucetContract = new this.ethers.Contract(this.faucetAddress, this.faucetABI, this.signer);
                    const tx = await faucetContract.claim({ gasLimit: 100000 });
                    await tx.wait();
                    this.log('✅ Faucet claim successful!', 'success');
                } catch (error) {
                    this.log('❌ Faucet claim failed: ' + error.message, 'error');
                }
            }
            
            async showPendingRewards() {
                const minerInfo = await this.contract.getMinerInfo(this.miningWallet.address);
                const pendingRewards = this.ethers.utils.formatEther(minerInfo[2]);
                this.log(`💰 Pending Rewards: ${pendingRewards} OMEGA`, 'info');
                if (parseFloat(pendingRewards) > 0) {
                    this.log('💡 Use "claim" command to collect rewards', 'info');
                }
            }
            
            async depositForMining() {
                this.log('💡 This feature is not yet implemented', 'info');
            }
            
            async deployContract() {
                this.log('💡 Contract deployment is handled separately', 'info');
            }
            
            async showContractInfo() {
                this.log(`📋 Mining Contract: ${this.contractAddress}`, 'info');
                this.log(`🚰 Faucet Contract: ${this.faucetAddress}`, 'info');
            }
            
            async startStressTest() {
                if (!this.ethers) {
                    this.log('Ethers library not loaded. Please refresh the page.', 'error');
                    return;
                }
                
                if (this.isStressTesting) {
                    this.log('Stress test already running. Use "stopstress" to stop it.', 'warning');
                    return;
                }
                
                // Generate a new wallet for the stress test
                this.stressWallet = this.ethers.Wallet.createRandom();
                this.log('🆕 Stress Test Wallet Generated:', 'info');
                this.logHtml('Address: <span class="copyable" onclick="navigator.clipboard.writeText(\'' + this.stressWallet.address + '\').then(() => window.terminal.log(\'✅ Address copied to clipboard!\', \'success\')).catch(() => window.terminal.log(\'❌ Failed to copy address\', \'error\'))">' + this.stressWallet.address + '</span>', 'output');
                this.logHtml('💡 <span style="color:#00ff99;cursor:pointer;text-decoration:underline;" onclick="window.terminal.fundStressWallet(\'0.001\')">[Click here to fund with 0.001 OMEGA]</span>', 'info');
                
                // Connect wallet to provider
                this.stressWallet = this.stressWallet.connect(this.provider);
                
                // Wait for funding
                this.log('⏳ Waiting for funding to initiate stress test...', 'info');
                this.isStressTesting = true;
                this.stressTestStats = {
                    walletsCreated: 0,
                    transactionsSent: 0,
                    successfulTxs: 0,
                    failedTxs: 0,
                    startTime: Date.now()
                };
                
                // Poll for funding every 5 seconds
                this.stressFundingInterval = setInterval(async () => {
                    const balance = await this.provider.getBalance(this.stressWallet.address);
                    if (!balance.isZero()) {
                        clearInterval(this.stressFundingInterval);
                        this.log('✅ Funding detected! Starting stress test...', 'success');
                        // Fetch and store the starting nonce
                        this.localNonce = await this.provider.getTransactionCount(this.stressWallet.address, 'latest');
                        this.startStressTestCycle();
                    }
                }, 5000);
            }

            startStressTestCycle() {
                this.stressTestInterval = setInterval(() => {
                    if (this.isStressTesting) {
                        this.runStressTestCycle();
                    }
                }, 3000);
                this.log('✅ Stress test will now begin!', 'success');
            }

            async runStressTestCycle() {
                try {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    const newWallet = this.ethers.Wallet.createRandom();
                    this.stressTestStats.walletsCreated++;
                    const gasPrice = await this.provider.getGasPrice();
                    
                    // Use and increment local nonce
                    const nonce = this.localNonce;
                    this.localNonce++;
                    
                    const tx = await this.stressWallet.sendTransaction({
                        to: newWallet.address,
                        value: 0,
                        gasLimit: 21000,
                        gasPrice: gasPrice,
                        nonce: nonce
                    });
                    
                    this.stressTestStats.transactionsSent++;
                    this.log(`📤 Sent empty tx to ${newWallet.address.slice(0, 10)}... (hash: ${tx.hash.slice(0, 10)}...)`, 'info');
                    this.stressTestStats.successfulTxs++;
                    
                } catch (err) {
                    this.stressTestStats.failedTxs++;
                    // If nonce error, re-sync local nonce
                    if (err.message && (err.message.includes('nonce') || err.message.includes('replacement'))) {
                        this.log('🔄 Nonce error detected, re-syncing nonce from network...', 'warning');
                        this.localNonce = await this.provider.getTransactionCount(this.stressWallet.address, 'latest');
                    } else if (err.message && err.message.includes('Internal JSON-RPC error')) {
                        this.log(`⚠️ RPC overload - slowing down...`, 'warning');
                        await new Promise(resolve => setTimeout(resolve, 2000));
                    } else {
                        this.log(`❌ Transaction failed: ${err.message}`, 'error');
                    }
                }
            }

            stopStressTest() {
                if (!this.isStressTesting) {
                    this.log('No stress test running.', 'warning');
                    return;
                }
                
                if (this.stressTestInterval) {
                    clearInterval(this.stressTestInterval);
                }
                if (this.stressFundingInterval) {
                    clearInterval(this.stressFundingInterval);
                }
                
                this.isStressTesting = false;
                this.log('🛑 Stress test stopped.', 'warning');
                this.showStressStats();
            }
            
            showStressStats() {
                if (!this.stressTestStats.startTime) {
                    this.log('No stress test has been run yet.', 'info');
                    return;
                }
                
                const runtime = Math.floor((Date.now() - this.stressTestStats.startTime) / 1000);
                const successRate = this.stressTestStats.transactionsSent > 0 
                    ? ((this.stressTestStats.successfulTxs / this.stressTestStats.transactionsSent) * 100).toFixed(1)
                    : 0;
                
                this.log('=== STRESS TEST STATISTICS ===', 'info');
                this.log(`Runtime: ${runtime} seconds`, 'output');
                this.log(`Wallets Created: ${this.stressTestStats.walletsCreated}`, 'output');
                this.log(`Transactions Sent: ${this.stressTestStats.transactionsSent}`, 'output');
                this.log(`Successful: ${this.stressTestStats.successfulTxs}`, 'success');
                this.log(`Failed: ${this.stressTestStats.failedTxs}`, 'error');
                this.log(`Success Rate: ${successRate}%`, 'output');
                this.log(`Status: ${this.isStressTesting ? 'RUNNING' : 'STOPPED'}`, this.isStressTesting ? 'success' : 'warning');
            }
            
            async showMiningStats() {
                await this.showStats();
            }
            
            async rickroll() {
                this.log('🎵 Never gonna give you up...', 'info');
                this.log('🎵 Never gonna let you down...', 'info');
                this.log('🎵 Never gonna run around and desert you...', 'info');
                this.log('🎵 Never gonna make you cry...', 'info');
                this.log('🎵 Never gonna say goodbye...', 'info');
                this.log('🎵 Never gonna tell a lie and hurt you...', 'info');
            }
            
            fortune() {
                const fortunes = [
                    "A beautiful, smart, and loving person will be coming into your life.",
                    "A dubious friend may be an enemy in camouflage.",
                    "A faithful friend is a strong defense.",
                    "A fresh start will put you on your way.",
                    "A golden egg of opportunity falls into your lap this month.",
                    "A lifetime friend shall soon be made.",
                    "A light heart carries you through all the hard times.",
                    "A new perspective will come with the new year.",
                    "A pleasant surprise is waiting for you.",
                    "A short pencil is usually better than a long memory any day."
                ];
                const fortune = fortunes[Math.floor(Math.random() * fortunes.length)];
                this.log(`🔮 Fortune: ${fortune}`, 'info');
            }
            
            async matrix() {
                this.log('🌐 Entering the Matrix...', 'info');
                for (let i = 0; i < 5; i++) {
                    await new Promise(resolve => setTimeout(resolve, 500));
                    this.log('01010101010101010101010101010101', 'output');
                }
                this.log('🌐 Matrix mode activated!', 'success');
            }
            
            async hack() {
                this.log('💻 Hacker mode activated...', 'info');
                this.log('🔓 Bypassing security protocols...', 'output');
                this.log('🔓 Accessing mainframe...', 'output');
                this.log('🔓 Downloading classified data...', 'output');
                this.log('✅ Hack complete! You are now a l33t h4x0r!', 'success');
            }
            
            async disco() {
                this.log('🕺 Disco mode activated!', 'info');
                this.log('💃 Stayin\' alive, stayin\' alive...', 'output');
                this.log('🎵 Ah, ha, ha, ha, stayin\' alive, stayin\' alive...', 'output');
                this.log('✨ Disco fever!', 'success');
            }
            
            sudoMine() {
                this.log('🔐 Sudo access granted!', 'info');
                this.log('⚡ Super user mining mode activated!', 'success');
                this.log('🚀 Mining with admin privileges...', 'output');
                this.totalEarned += 0.1;
                this.log('💰 Admin bonus: +0.1 OMEGA', 'success');
            }

            async fundMiningWallet(amount) {
                if (!this.signer) {
                    this.log('Please connect your wallet first using: connect', 'error');
                    return;
                }
                if (!this.miningWallet) {
                    this.log('No mining wallet found. Start mining first.', 'error');
                    return;
                }
                if (!amount || isNaN(amount) || Number(amount) <= 0) {
                    this.log('Invalid amount. Usage: fund <amount>', 'error');
                    return;
                }
                try {
                    this.log(`💰 Funding mining wallet with ${amount} OMEGA...`, 'info');
                    const tx = await this.signer.sendTransaction({
                        to: this.miningWallet.address,
                        value: this.ethers.utils.parseEther(amount),
                        gasLimit: 21000
                    });
                    this.log(`📤 Funding transaction sent: ${tx.hash}`, 'info');
                    this.log('⏳ Waiting for confirmation... (this may take a few seconds)', 'info');
                    await tx.wait();
                    this.log(`✅ Mining wallet funded with ${amount} OMEGA!`, 'success');
                } catch (error) {
                    if (error.code === 4001) {
                        this.log('❌ Transaction rejected by user.', 'error');
                    } else {
                        this.log('❌ Failed to fund mining wallet: ' + error.message, 'error');
                    }
                }
            }

            async fundStressWallet(amount) {
                if (!this.signer) {
                    this.log('Please connect your wallet first using: connect', 'error');
                    return;
                }
                if (!this.stressWallet) {
                    this.log('No stress test wallet found. Start stress test first.', 'error');
                    return;
                }
                if (!amount || isNaN(amount) || Number(amount) <= 0) {
                    this.log('Invalid amount. Usage: fund <amount>', 'error');
                    return;
                }
                try {
                    this.log(`💰 Funding stress test wallet with ${amount} OMEGA...`, 'info');
                    const tx = await this.signer.sendTransaction({
                        to: this.stressWallet.address,
                        value: this.ethers.utils.parseEther(amount),
                        gasLimit: 21000
                    });
                    this.log(`📤 Funding transaction sent: ${tx.hash}`, 'info');
                    this.log('⏳ Waiting for confirmation... (this may take a few seconds)', 'info');
                    await tx.wait();
                    this.log(`✅ Stress test wallet funded with ${amount} OMEGA!`, 'success');
                } catch (error) {
                    if (error.code === 4001) {
                        this.log('❌ Transaction rejected by user.', 'error');
                    } else {
                        this.log('❌ Failed to fund stress test wallet: ' + error.message, 'error');
                    }
                }
            }

            async setTheme(theme) {
                const validThemes = ['dark', 'light', 'matrix', 'retro'];
                if (!validThemes.includes(theme)) {
                    this.log('Invalid theme. Available: dark, light, matrix, retro', 'error');
                    return;
                }
                document.body.classList.remove('theme-dark', 'theme-light', 'theme-matrix', 'theme-retro');
                document.body.classList.add('theme-' + theme);
                const terminal = document.getElementById('terminal');
                if (terminal) {
                    terminal.classList.remove('theme-dark', 'theme-light', 'theme-matrix', 'theme-retro');
                    terminal.classList.add('theme-' + theme);
                }
                localStorage.setItem('omega-terminal-theme', theme);
                this.log(`Theme set to ${theme} mode`, 'success');
            }

            toggleTheme() {
                this.isDarkTheme = !this.isDarkTheme;
                this.applyTheme();
                localStorage.setItem('omega-miner-theme', this.isDarkTheme ? 'dark' : 'light');
            }
            
            applyTheme() {
                const theme = localStorage.getItem('omega-terminal-theme') || 'dark';
                document.body.classList.remove('theme-dark', 'theme-light', 'theme-matrix', 'theme-retro');
                document.body.classList.add('theme-' + theme);
                const terminal = document.getElementById('terminal');
                if (terminal) {
                    terminal.classList.remove('theme-dark', 'theme-light', 'theme-matrix', 'theme-retro');
                    terminal.classList.add('theme-' + theme);
                }
                const themeToggle = document.querySelector('.theme-toggle');
                if (themeToggle) {
                    if (theme === 'dark') themeToggle.textContent = '☀️ Light';
                    else if (theme === 'light') themeToggle.textContent = '🌙 Dark';
                    else if (theme === 'matrix') themeToggle.textContent = '🟩 Matrix';
                    else if (theme === 'retro') themeToggle.textContent = '🟨 Retro';
                }
            }

            async sendOmega(command) {
                if (!this.signer) {
                    this.log('Please connect your wallet first using: connect', 'error');
                    return;
                }
                // Parse command: send <address> <amount>
                const parts = command.trim().split(/\s+/);
                if (parts.length !== 3) {
                    this.log('Usage: send <address> <amount>', 'warning');
                    return;
                }
                const address = parts[1];
                const amountStr = parts[2];
                if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {
                    this.log('Invalid address format.', 'error');
                    return;
                }
                let amount;
                try {
                    amount = this.ethers.utils.parseEther(amountStr);
                } catch (e) {
                    this.log('Invalid amount.', 'error');
                    return;
                }
                this.log(`🚀 Sending ${amountStr} OMEGA to ${address}...`, 'info');
                try {
                    const tx = await this.signer.sendTransaction({
                        to: address,
                        value: amount
                    });
                    this.log('⏳ Waiting for confirmation...', 'info');
                    await tx.wait();
                    this.log(`✅ Sent ${amountStr} OMEGA to ${address}!`, 'success');
                } catch (error) {
                    this.log('❌ Send failed: ' + error.message, 'error');
                }
            }

            async claim() {
                if (!this.signer) {
                    this.log('Please connect wallet first using "connect" command', 'error');
                    return;
                }
                if (!this.miningWallet) {
                    this.log('No mining wallet found. Start mining first.', 'error');
                    return;
                }
                try {
                    const wasMining = this.isMining;
                    if (wasMining) this.isMining = false;
                    const miningAddress = this.miningWallet.address;
                    const userAddress = await this.signer.getAddress();
                    this.log(`💰 Claiming rewards from mining wallet (${miningAddress}) to your wallet (${userAddress})...`, 'info');
                    // Claim rewards from contract
                    const minerInfo = await this.contract.getMinerInfo(miningAddress);
                    const pendingRewards = minerInfo[2];
                    if (pendingRewards.isZero()) {
                        this.log('⚠️ No pending rewards found in contract for mining wallet.', 'warning');
                        return;
                    }
                    // Log mining wallet balance and estimated gas
                    const balance = await this.provider.getBalance(miningAddress);
                    const gasPrice = await this.provider.getGasPrice();
                    const gasLimit = 100000;
                    const minClaimGas = this.ethers.utils.parseEther('0.002');
                    const estimatedGas = gasPrice.mul(gasLimit);
                    this.log(`Mining wallet balance: ${this.ethers.utils.formatEther(balance)} OMEGA`, 'info');
                    this.log(`Estimated gas required for claim: ${this.ethers.utils.formatEther(estimatedGas)} OMEGA`, 'info');
                    if (balance.lt(minClaimGas)) {
                        this.log('⚠️ Not enough OMEGA in mining wallet to pay gas for claim. Please fund it with at least 0.002 OMEGA.', 'warning');
                        return;
                    }
                    const claimTx = await this.contract.connect(this.miningWallet).claimTo(userAddress, { gasLimit });
                    await claimTx.wait();
                    this.logHtml(`Transaction hash: <span class=\"copyable\" onclick=\"navigator.clipboard.writeText('${claimTx.hash}').then(() => window.terminal.log('✅ Transaction hash copied to clipboard!', 'success')).catch(() => window.terminal.log('❌ Failed to copy transaction hash', 'error'))\">${claimTx.hash}</span>`, 'info');
                    const updatedMinerInfo = await this.contract.getMinerInfo(this.miningWallet.address);
                    this.totalEarned = parseFloat(this.ethers.utils.formatEther(updatedMinerInfo[2]));
                    if (wasMining) this.isMining = true;
                } catch (error) {
                    this.log(`❌ Claim failed: ${error.message}`, 'error');
                }
            }
        }
    </script>
    <script>
        window.terminal = new OmegaMinerTerminal();
    </script>
</body>
</html>
