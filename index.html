<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Omega Terminal - Mining Interface</title>
    <script src="https://cdn.ethers.io/lib/ethers-5.7.2.umd.min.js" type="application/javascript"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #000;
            color: #ffffff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
            overflow: hidden;
        }

        .terminal {
            width: 100vw;
            height: 100vh;
            padding: 20px;
            background: linear-gradient(135deg, #000 0%, #111111 100%);
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .terminal-header {
            border-bottom: 1px solid #ffffff;
            padding-bottom: 10px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .terminal-title {
            font-size: 28px;
            font-weight: bold;
            text-shadow: 0 0 15px #ffffff, 0 0 30px #ffffff;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .terminal-status {
            font-size: 12px;
            color: #cccccc;
        }

        .theme-toggle {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #ffffff;
            color: #ffffff;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .theme-toggle:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        .terminal-input-section {
            border-top: 1px solid #ffffff;
            padding-top: 10px;
            margin-top: auto;
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #ffffff;
        }

        .terminal-content {
            flex: 1;
            overflow-y: auto;
            padding-right: 10px;
            margin-bottom: 20px;
        }

        .terminal-line {
            margin-bottom: 5px;
            word-wrap: break-word;
        }

        .prompt {
            color: #ffffff;
            font-weight: bold;
        }

        .command {
            color: #ffffff;
        }

        .output {
            color: #cccccc;
            margin-left: 20px;
        }

        .error {
            color: #ff6666;
        }

        .success {
            color: #ffffff;
        }

        .warning {
            color: #ffffcc;
        }

        .info {
            color: #99ccff;
        }

        .mining-status {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #ffffff;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #111111;
            border: 1px solid #ffffff;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffffff, #cccccc);
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px #ffffff;
        }

        .input-line {
            display: flex;
            align-items: center;
            background: transparent;
        }

        .input-prompt {
            color: #ffffff;
            font-weight: bold;
            margin-right: 10px;
            font-size: 16px;
        }

        .input-field {
            background: transparent;
            border: none;
            color: #ffffff;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            outline: none;
            flex: 1;
            padding: 5px;
        }

        .input-field::placeholder {
            color: #666666;
        }

        .cursor {
            animation: blink 1s infinite;
            color: #ffffff;
            font-size: 16px;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .mining-animation {
            display: inline-block;
            animation: mining-pulse 2s infinite;
        }

        @keyframes mining-pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }

        .stat-box {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #ffffff;
            padding: 10px;
            border-radius: 5px;
        }

        .stat-label {
            color: #cccccc;
            font-size: 12px;
        }

        .stat-value {
            color: #ffffff;
            font-size: 16px;
            font-weight: bold;
        }

        /* Boot Animation Styles */
        .boot-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            font-family: 'Courier New', monospace;
        }

        .omega-symbols {
            font-size: 48px;
            color: #ffffff;
            text-shadow: 0 0 20px #ffffff;
            margin-bottom: 20px;
            animation: omega-float 3s ease-in-out infinite;
        }

        .pickaxe {
            font-size: 36px;
            color: #ffcc00;
            text-shadow: 0 0 15px #ffcc00;
            animation: pickaxe-swing 2s ease-in-out infinite;
            margin-bottom: 30px;
        }

        .welcome-text {
            font-size: 24px;
            color: #ffffff;
            text-align: center;
            line-height: 1.5;
            text-shadow: 0 0 10px #ffffff;
        }

        .loading-dots {
            font-size: 18px;
            color: #cccccc;
            margin-top: 20px;
            animation: loading-pulse 1.5s ease-in-out infinite;
        }

        @keyframes omega-float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        @keyframes pickaxe-swing {
            0%, 100% { transform: rotate(-15deg); }
            50% { transform: rotate(15deg); }
        }

        @keyframes loading-pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        .hidden {
            display: none !important;
        }

        /* Light Theme Styles */
        .terminal.light-theme {
            background: linear-gradient(135deg, #f5f5f5 0%, #e0e0e0 100%);
            color: #000000;
        }

        .terminal.light-theme .terminal-header {
            border-bottom: 1px solid #000000;
        }

        .terminal.light-theme .terminal-title {
            color: #000000;
            text-shadow: 0 0 15px #000000, 0 0 30px #000000;
        }

        .terminal.light-theme .terminal-status {
            color: #333333;
        }

        .terminal.light-theme .theme-toggle {
            background: rgba(0, 0, 0, 0.1);
            border: 1px solid #000000;
            color: #000000;
        }

        .terminal.light-theme .theme-toggle:hover {
            background: rgba(0, 0, 0, 0.2);
        }

        .terminal.light-theme .terminal-input-section {
            border-top: 1px solid #000000;
            background: rgba(0, 0, 0, 0.05);
            border: 1px solid #000000;
        }

        .terminal.light-theme .prompt {
            color: #000000;
        }

        .terminal.light-theme .command {
            color: #000000;
        }

        .terminal.light-theme .output {
            color: #333333;
        }

        .terminal.light-theme .error {
            color: #cc0000;
        }

        .terminal.light-theme .success {
            color: #000000;
        }

        .terminal.light-theme .warning {
            color: #cc6600;
        }

        .terminal.light-theme .info {
            color: #0066cc;
        }

        .terminal.light-theme .input-prompt {
            color: #000000;
        }

        .terminal.light-theme .input-field {
            color: #000000;
        }

        .terminal.light-theme .input-field::placeholder {
            color: #666666;
        }

        .terminal.light-theme .cursor {
            color: #000000;
        }

        .terminal.light-theme .mining-status {
            background: rgba(0, 0, 0, 0.1);
            border: 1px solid #000000;
        }

        .terminal.light-theme .stat-box {
            background: rgba(0, 0, 0, 0.05);
            border: 1px solid #000000;
        }

        .terminal.light-theme .stat-label {
            color: #333333;
        }

        .terminal.light-theme .stat-value {
            color: #000000;
        }

        .output.error {
            color: #ff3333 !important;
            font-weight: bold !important;
        }

        /* --- FORCE RED AND BOLD FOR ERROR OUTPUT --- */
        .terminal-content .output.error,
        .output.error {
            color: #ff3333 !important;
            font-weight: bold !important;
        }
    </style>
</head>
<body>
    <!-- Boot Animation -->
    <div class="boot-animation" id="bootAnimation">
        <div class="omega-symbols">Œ© Œ© Œ© Œ© Œ©</div>
        <div class="pickaxe">‚õèÔ∏è</div>
        <div class="welcome-text">
            Welcome to Omega Miner v1.0.0<br>
            <span style="font-size: 16px; color: #cccccc;">Type below to get started</span>
        </div>
        <div class="loading-dots">Loading...</div>
    </div>

    <div class="terminal" id="terminal" style="display: none;">
        <div class="terminal-header">
            <div class="terminal-title">OMEGA MINING TERMINAL v1.0.0</div>
            <div class="terminal-status" id="connectionStatus">DISCONNECTED</div>
            <button class="theme-toggle">Toggle Theme</button>
        </div>
        
        <div class="terminal-content" id="terminalContent">
            <div class="terminal-line">
                <span class="prompt">root@omega-miner:~$</span>
                <span class="command"> ./omega-miner --version</span>
            </div>
            <div class="output">Omega Mining Terminal v1.0.0</div>
            <div class="output">Connected to Omega Network (Chain ID: 1313161768)</div>
            <div class="output">Mining Contract: <span id="contractAddress">Not deployed</span></div>
            <div class="terminal-line">
                <span class="prompt">root@omega-miner:~$</span>
                <span class="command"> ./omega-miner --help</span>
            </div>
            <div class="output">Available commands:</div>
            <div class="output">  connect          - Connect wallet</div>
            <div class="output">  mine             - Start mining</div>
            <div class="output">  status           - Show mining status</div>
            <div class="output">  stats            - Show mining statistics</div>
            <div class="output">  balance          - Show wallet balance</div>
            <div class="output">  stress           - Start stress test</div>
            <div class="output">  stopstress       - Stop stress test</div>
            <div class="output">  stressstats      - Show stress test statistics</div>
            <div class="output">  help             - Show this help</div>
            <div class="output">  clear            - Clear terminal</div>
        </div>

        <div class="terminal-input-section">
            <div class="input-line">
                <span class="input-prompt">root@omega-miner:~$</span>
                <input type="text" class="input-field" id="commandInput" placeholder="Enter command..." autocomplete="off">
                <span class="cursor">|</span>
            </div>
        </div>
    </div>

    <script>
        // Simplified ethers loading with fallback support
        function loadEthers() {
            return new Promise((resolve, reject) => {
                // Small delay to ensure CDN script has time to load
                setTimeout(() => {
                    console.log('Checking for ethers availability...');
                    
                    // Check if ethers is already loaded (CDN success)
                    if (typeof ethers !== 'undefined') {
                        console.log('Ethers loaded successfully from CDN');
                        resolve(ethers);
                        return;
                    }
                    
                    console.log('CDN ethers not loaded, trying additional CDN sources...');
                    
                    // Try multiple CDN sources
                    const cdnSources = [
                        'https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js',
                        'https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js'
                    ];
                    
                    let currentSource = 0;
                    
                    function tryNextSource() {
                        if (currentSource >= cdnSources.length) {
                            // All CDN sources failed, load fallback
                            console.log('All CDN sources failed, loading fallback ethers...');
                            loadEthersFallback();
                            resolve(ethers);
                            return;
                        }
                        
                        const script = document.createElement('script');
                        script.src = cdnSources[currentSource];
                        script.onload = () => {
                            if (typeof ethers !== 'undefined') {
                                console.log(`Ethers loaded successfully from: ${cdnSources[currentSource]}`);
                                resolve(ethers);
                            } else {
                                currentSource++;
                                tryNextSource();
                            }
                        };
                        script.onerror = () => {
                            console.warn(`Failed to load ethers from: ${cdnSources[currentSource]}`);
                            currentSource++;
                            tryNextSource();
                        };
                        document.head.appendChild(script);
                    }
                    
                    tryNextSource();
                }, 500); // 500ms delay to ensure CDN script has time to load
            });
        }

        // Fallback ethers implementation - only loads if all CDN sources fail
        function loadEthersFallback() {
            console.log('Loading ethers fallback...');
            window.ethers = {
                providers: {
                    Web3Provider: function(provider) {
                        this.provider = provider;
                        this.getSigner = () => ({ 
                            getAddress: () => Promise.resolve('0x0000000000000000000000000000000000000000'),
                            sendTransaction: () => Promise.reject(new Error('Fallback ethers - no real transactions'))
                        });
                        this.getGasPrice = () => Promise.resolve({ toString: () => '20000000000' });
                        this.getBalance = () => Promise.resolve({ isZero: () => true });
                        this.getTransactionCount = () => Promise.resolve(0);
                    }
                },
                Contract: function(address, abi, signer) {
                    this.address = address;
                    this.abi = abi;
                    this.signer = signer;
                    // Add basic contract methods
                    this.startMining = () => Promise.resolve({ wait: () => Promise.resolve() });
                    this.claimRewards = () => Promise.resolve({ wait: () => Promise.resolve() });
                },
                Wallet: {
                    createRandom: function() {
                        return {
                            address: '0x' + Math.random().toString(16).substr(2, 40),
                            privateKey: '0x' + Math.random().toString(16).substr(2, 64),
                            connect: function(provider) { return this; },
                            sendTransaction: function(tx) { 
                                return Promise.resolve({ 
                                    hash: '0x' + Math.random().toString(16).substr(2, 64),
                                    wait: () => Promise.resolve()
                                }); 
                            }
                        };
                    }
                },
                utils: {
                    formatEther: (wei) => (parseInt(wei) / 1e18).toString(),
                    parseEther: (ether) => (parseFloat(ether) * 1e18).toString(),
                    id: (text) => '0x' + Math.random().toString(16).substr(2, 64),
                    defaultAbiCoder: {
                        decode: () => ['0x0000000000000000000000000000000000000000', '1000000000000000000', '1']
                    },
                    hexDataSlice: (data, start) => data
                }
            };
            console.log('Ethers fallback loaded successfully');
        }

        class OmegaMinerTerminal {
            constructor() {
                this.provider = null;
                this.signer = null;
                this.contract = null;
                this.isMining = false;
                this.miningInterval = null;
                this.currentNonce = 0;
                this.ethers = null;
                this.isDarkTheme = true; // Default to dark theme
                
                // New mining system properties
                this.pendingClaimableBalance = 0;
                this.waitingForContinueResponse = false;
                
                // Stress test properties
                this.isStressTesting = false;
                this.stressTestInterval = null;
                this.stressTestStats = {
                    walletsCreated: 0,
                    transactionsSent: 0,
                    successfulTxs: 0,
                    failedTxs: 0,
                    startTime: 0
                };
                this.stressWallet = null;
                this.stressNonce = 0;
                
                // Contract properties
                this.contractAddress = '0x0d4a5d6d28ce3d79dfd145b3ca5286a50c2f9895'; // Deployed OmegaMiner contract
                this.faucetAddress = '0x5a8b762b3b3e9e505288af5494d83e631d9cf2cb'; // Deployed OmegaFaucet contract
                this.contractABI = [
                    "function depositForMining() external payable",
                    "function startMining() external",
                    "function mineBlock(uint256 nonce, bytes32 solution) external",
                    "function claimRewards() external",
                    "function getMinerInfo(address miner) external view returns (uint256, uint256, uint256, bool, uint256)",
                    "function getContractStats() external view returns (uint256, uint256, uint256)",
                    "function miningDifficulty() external view returns (uint256)",
                    "function mineCooldown() external view returns (uint256)",
                    "function maxRewardPerUser() external view returns (uint256)",
                    "event TokensDeposited(address indexed user, uint256 amount)",
                    "event MiningStarted(address indexed user)",
                    "event BlockMined(address indexed user, uint256 nonce, bytes32 solution, uint256 reward)",
                    "event WholeBlockMined(address indexed user, uint256 nonce, bytes32 solution)",
                    "event RewardsClaimed(address indexed user, uint256 amount)"
                ];
                this.faucetABI = [
                    {
                        "inputs": [],
                        "name": "startMining",
                        "outputs": [],
                        "stateMutability": "nonpayable",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "claimReward",
                        "outputs": [{"type": "uint256"}],
                        "stateMutability": "nonpayable",
                        "type": "function"
                    },
                    {
                        "inputs": [{"type": "address"}],
                        "name": "getMiningSession",
                        "outputs": [
                            {"type": "uint256"},
                            {"type": "uint256"},
                            {"type": "uint256"},
                            {"type": "uint256"},
                            {"type": "bool"}
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "getFaucetBalance",
                        "outputs": [{"type": "uint256"}],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "claim",
                        "outputs": [],
                        "stateMutability": "nonpayable",
                        "type": "function"
                    }
                ];
                
                this.init();
            }
            
            async init() {
                console.log('OmegaMinerTerminal initializing...');
                
                // Load saved theme preference
                this.loadThemePreference();
                
                // Show boot animation first
                await this.showBootAnimation();
                
                try {
                    console.log('Loading ethers library...');
                    this.ethers = await loadEthers();
                    console.log('Ethers library loaded successfully');
                    this.log('Ethers library loaded successfully', 'success');
                    this.setupEventListeners();
                    this.checkWalletConnection();
                } catch (error) {
                    console.error('Failed to load ethers:', error);
                    this.log('Failed to load ethers library: ' + error.message, 'error');
                    this.log('Please check your internet connection and refresh the page', 'error');
                    // Still show the terminal even if ethers fails
                    this.setupEventListeners();
                }
            }
            
            loadThemePreference() {
                const savedTheme = localStorage.getItem('omega-miner-theme');
                if (savedTheme === 'light') {
                    this.isDarkTheme = false;
                    this.applyTheme();
                }
            }
            
            toggleTheme() {
                this.isDarkTheme = !this.isDarkTheme;
                this.applyTheme();
                localStorage.setItem('omega-miner-theme', this.isDarkTheme ? 'dark' : 'light');
            }
            
            applyTheme() {
                const terminal = document.getElementById('terminal');
                const themeToggle = document.querySelector('.theme-toggle');
                
                if (this.isDarkTheme) {
                    terminal.classList.remove('light-theme');
                    themeToggle.textContent = '‚òÄÔ∏è Light';
                } else {
                    terminal.classList.add('light-theme');
                    themeToggle.textContent = 'üåô Dark';
                }
            }
            
            async showBootAnimation() {
                console.log('Showing boot animation...');
                return new Promise((resolve) => {
                    setTimeout(() => {
                        console.log('Hiding boot animation, showing terminal...');
                        // Hide boot animation and show terminal
                        document.getElementById('bootAnimation').style.display = 'none';
                        document.getElementById('terminal').style.display = 'flex';
                        
                        // Apply theme after terminal is shown
                        this.applyTheme();
                        
                        console.log('Terminal ready!');
                        resolve();
                    }, 3000); // Show animation for 3 seconds
                });
            }
            
            setupEventListeners() {
                const input = document.getElementById('commandInput');
                if (input) {
                    input.focus();
                    input.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            this.executeCommand(input.value);
                            input.value = '';
                        }
                        // Ctrl+C to stop stress test
                        if (e.key === 'c' && e.ctrlKey) {
                            if (this.isStressTesting) {
                                this.stopStressTest();
                                this.log('^C (stress test stopped by user)', 'warning');
                            }
                        }
                    });
                }
                
                // Setup theme toggle
                const themeToggle = document.querySelector('.theme-toggle');
                if (themeToggle) {
                    themeToggle.addEventListener('click', () => {
                        this.toggleTheme();
                    });
                    // Set initial button text
                    themeToggle.textContent = this.isDarkTheme ? '‚òÄÔ∏è Light' : 'üåô Dark';
                }
            }
            
            async checkWalletConnection() {
                if (typeof window.ethereum !== 'undefined') {
                    try {
                        const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                        if (accounts.length > 0) {
                            await this.connectWallet();
                        }
                    } catch (error) {
                        this.log('Error checking wallet connection: ' + error.message, 'error');
                    }
                }
            }
            
            async connectWallet() {
                try {
                    if (!this.ethers) {
                        this.log('Ethers library not loaded. Please refresh the page.', 'error');
                        return;
                    }

                    if (typeof window.ethereum === 'undefined') {
                        this.log('MetaMask not found. Please install MetaMask.', 'error');
                        return;
                    }
                    
                    this.log('üîó Connecting to MetaMask...', 'info');
                    
                    // Request account access
                    try {
                        await window.ethereum.request({ method: 'eth_requestAccounts' });
                        this.log('‚úÖ MetaMask account access granted', 'success');
                    } catch (requestError) {
                        this.log('‚ùå MetaMask connection denied by user', 'error');
                        return;
                    }
                    
                    this.provider = new this.ethers.providers.Web3Provider(window.ethereum);
                    this.signer = this.provider.getSigner();
                    
                    this.log('üîç Getting wallet address...', 'info');
                    const address = await this.signer.getAddress();
                    
                    // Check if we're using fallback ethers (which would return 0x000... address)
                    if (address === '0x0000000000000000000000000000000000000000') {
                        this.log('‚ö†Ô∏è Using fallback ethers - real transactions not available', 'warning');
                        this.log('üí° Please check your internet connection and refresh the page', 'info');
                        return;
                    }
                    
                    this.log(`‚úÖ Wallet connected: ${address}`, 'success');
                    this.updateConnectionStatus('CONNECTED');
                    
                    if (this.contractAddress !== '0x0000000000000000000000000000000000000000') {
                        this.contract = new this.ethers.Contract(this.contractAddress, this.contractABI, this.signer);
                        this.log('‚úÖ Mining contract connected', 'success');
                    }
                    
                } catch (error) {
                    console.error('Connect wallet error:', error);
                    this.log('‚ùå Failed to connect wallet: ' + error.message, 'error');
                    this.log('üí° Make sure MetaMask is unlocked and you approve the connection', 'info');
                }
            }
            
            async disconnectWallet() {
                try {
                    if (!this.signer) {
                        this.log('No wallet connected to disconnect.', 'warning');
                        return;
                    }
                    
                    // Get the address before disconnecting for the message
                    const address = await this.signer.getAddress();
                    
                    // Clear all wallet-related properties
                    this.provider = null;
                    this.signer = null;
                    this.contract = null;
                    this.pendingClaimableBalance = 0;
                    
                    this.log(`üîå Wallet disconnected: ${address}`, 'success');
                    this.updateConnectionStatus('DISCONNECTED');
                    this.log('üí° Use "connect" command to reconnect your wallet', 'info');
                    
                } catch (error) {
                    console.error('Disconnect wallet error:', error);
                    this.log('‚ùå Error disconnecting wallet: ' + error.message, 'error');
                }
            }
            
            async executeCommand(command) {
                const cmd = command.trim().toLowerCase();
                this.logCommand(command);
                
                // Handle continue mining response
                if (this.waitingForContinueResponse) {
                    this.waitingForContinueResponse = false;
                    if (cmd === 'yes' || cmd === 'y') {
                        this.log('‚úÖ Continuing mining...', 'success');
                        await this.startMiningStressTest();
                        return;
                    } else {
                        this.log('üëã Mining session ended. Thanks for mining!', 'info');
                        return;
                    }
                }
                
                switch (cmd) {
                    case 'connect':
                        await this.connectWallet();
                        break;
                    case 'disconnect':
                        await this.disconnectWallet();
                        break;
                    case 'mine':
                        await this.startMiningStressTest();
                        break;
                    case 'session':
                        await this.startMiningSession();
                        break;
                    case 'faucet':
                        await this.faucetClaim();
                        break;
                    case 'claim':
                        await this.claimFaucet();
                        break;
                    case 'pending':
                        await this.showPendingRewards();
                        break;
                    case 'balance':
                        await this.showBalance();
                        break;
                    case 'stop':
                        this.stopAll();
                        break;
                    case 'status':
                        await this.showStatus();
                        break;
                    case 'stats':
                        await this.showStats();
                        break;
                    case 'deposit':
                        await this.depositForMining();
                        break;
                    case 'deploy':
                        await this.deployContract();
                        break;
                    case 'contract':
                        await this.showContractInfo();
                        break;
                    case 'stress':
                        await this.startStressTest();
                        break;
                    case 'stopstress':
                        this.stopStressTest();
                        break;
                    case 'stressstats':
                        this.showStressStats();
                        break;
                    case 'theme':
                        this.toggleTheme();
                        this.log(`Theme switched to ${this.isDarkTheme ? 'dark' : 'light'} mode`, 'success');
                        break;
                    case 'help':
                        this.showHelp();
                        break;
                    case 'clear':
                        this.clearTerminal();
                        break;
                    default:
                        if (cmd) {
                            this.log(`Command not found: ${command}`, 'error');
                            this.log('Type "help" for available commands', 'info');
                        }
                }
            }
            
            async startMiningStressTest() {
                if (this.isMining) {
                    this.log('Mining already in progress', 'warning');
                    return;
                }
                
                if (!this.signer) {
                    this.log('Please connect wallet first using "connect" command', 'error');
                    return;
                }
                
                // Check if we're using fallback ethers
                try {
                    const address = await this.signer.getAddress();
                    if (address === '0x0000000000000000000000000000000000000000') {
                        this.log('‚ùå Cannot mine with fallback ethers - no real transactions available', 'error');
                        this.log('üí° Please refresh the page and ensure ethers.js loads from CDN', 'info');
                        return;
                    }
                } catch (error) {
                    this.log('‚ùå Cannot verify wallet connection - please reconnect', 'error');
                    return;
                }
                
                this.isMining = true;
                this.log('‚õèÔ∏è Starting Omega mining...', 'info');
                this.log('Omega Mining is the easiest way to earn Omega Token. Happy Mining!', 'info');
                this.log('------------------------------------------', 'info');
                
                let blockCount = 0;
                let claimableBalance = 0;
                let hasGivenFirstBonus = false;
                const miningAnimations = ['‚õèÔ∏è','ü™ì','‚öíÔ∏è','üî®','Œ©'];
                let animIndex = 0;
                
                // Check if this is the first time mining (for 0.1 OMEGA bonus)
                const firstTimeKey = 'omega-miner-first-bonus';
                const hasReceivedFirstBonus = localStorage.getItem(firstTimeKey);
                
                // Start mining loop
                while (this.isMining) {
                    try {
                        // Use the user's connected wallet for transactions
                        const address = await this.signer.getAddress();
                        const toAddress = this.ethers.Wallet.createRandom().address;
                        
                        const gasPrice = await this.provider.getGasPrice();
                        const tx = await this.signer.sendTransaction({
                            to: toAddress,
                            value: 0,
                            gasLimit: 21000,
                            gasPrice: gasPrice
                        });
                        
                        blockCount++;
                        const anim = miningAnimations[animIndex % miningAnimations.length];
                        this.log(`${anim} Mining... [Block #${blockCount}] Œ© Sent tx: ${tx.hash.slice(0, 12)}...`, 'output');
                        animIndex++;
                        
                        await tx.wait();
                        this.log(`üü¢ Transaction confirmed: ${tx.hash.slice(0, 12)}...`, 'success');
                        
                        // First-time bonus (0.1 OMEGA in first 5 seconds)
                        if (!hasGivenFirstBonus && !hasReceivedFirstBonus && blockCount <= 5) {
                            claimableBalance += 0.1;
                            hasGivenFirstBonus = true;
                            localStorage.setItem(firstTimeKey, 'true');
                            this.log(`üéÅ FIRST-TIME BONUS! +0.1 OMEGA`, 'success');
                        }
                        
                        // Random reward chance (average 0.0001 per minute)
                        const rewardChance = Math.random();
                        if (rewardChance < 0.15) { // 15% chance per block (roughly 0.0001/min)
                            let rewardAmount;
                            const rareChance = Math.random();
                            
                            if (rareChance < 0.001) { // 0.1% chance for max reward
                                rewardAmount = 1.0;
                                this.log(`üéâ JACKPOT! +${rewardAmount} OMEGA`, 'success');
                            } else if (rareChance < 0.01) { // 0.9% chance for medium reward
                                rewardAmount = 0.01;
                                this.log(`üéä MEDIUM REWARD! +${rewardAmount} OMEGA`, 'success');
                            } else { // Normal small reward
                                rewardAmount = 0.0001 + (Math.random() * 0.0009); // 0.0001 to 0.001
                                this.log(`üí∞ REWARD! +${rewardAmount.toFixed(6)} OMEGA`, 'success');
                            }
                            
                            claimableBalance += rewardAmount;
                        }
                        
                        // Update the pending claimable balance property
                        this.pendingClaimableBalance = claimableBalance;
                        
                        // Display current claimable balance
                        if (claimableBalance > 0) {
                            this.log(`üí≥ Current Claimable Balance: ${claimableBalance.toFixed(6)} OMEGA`, 'info');
                        }
                        
                    } catch (err) {
                        this.log(`‚ùå Mining tx failed: ${err.message}`, 'error');
                    }
                    
                    await new Promise(r => setTimeout(r, 1000));
                }
                
                this.isMining = false;
                this.log('‚õî Mining stopped.', 'warning');
                this.log(`üìä Mining Summary: ${blockCount} blocks mined`, 'info');
                
                if (claimableBalance > 0) {
                    this.log(`üí∞ Final Claimable Balance: ${claimableBalance.toFixed(6)} OMEGA`, 'success');
                    this.log(`üí° Type 'claim' to collect your rewards!`, 'success');
                    
                    // Ask if they want to continue mining
                    this.log('ü§î Do you want to continue mining? (Type "yes" to continue, anything else to stop)', 'info');
                    this.waitingForContinueResponse = true;
                    this.pendingClaimableBalance = claimableBalance;
                } else {
                    this.log('üí° No rewards earned this session. Try mining again!', 'info');
                }
            }
            
            async claimFaucet() {
                if (!this.signer) {
                    this.log('Please connect wallet first using "connect" command', 'error');
                    return;
                }
                
                if (this.pendingClaimableBalance <= 0) {
                    this.log('‚ùå No rewards available to claim. Mine first to earn rewards!', 'warning');
                    return;
                }
                
                try {
                    const address = await this.signer.getAddress();
                    const rewardAmount = this.pendingClaimableBalance;
                    
                    this.log(`üí∞ Claiming ${rewardAmount.toFixed(6)} OMEGA...`, 'info');
                    this.log('‚è≥ Processing reward transfer...', 'info');
                    
                    // Simulate the reward process
                    this.log(`üì¶ Reward transaction simulated: 0x${Math.random().toString(16).substr(2, 64)}`, 'info');
                    this.log('‚è≥ Waiting for confirmation...', 'info');
                    
                    // Simulate transaction confirmation
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    
                    this.log(`üéâ REWARDS CLAIMED! +${rewardAmount.toFixed(6)} OMEGA sent to ${address}`, 'success');
                    this.log(`‚úÖ Your mining rewards have been processed!`, 'success');
                    
                    // Reset the pending balance
                    this.pendingClaimableBalance = 0;
                    
                    // Ask if they want to continue mining
                    this.log('ü§î Do you want to continue mining? (Type "yes" to continue, anything else to stop)', 'info');
                    this.waitingForContinueResponse = true;
                    
                } catch (error) {
                    console.error('Claim error:', error);
                    this.log(`‚ùå Failed to claim rewards: ${error.message}`, 'error');
                    this.log('üí° Please try again or contact support', 'info');
                }
            }

            stopMining() {
                this.isMining = false;
            }
            
            stopAll() {
                let stoppedSomething = false;
                
                // Stop mining if running
                if (this.isMining) {
                    this.stopMining();
                    this.log('‚õî Mining stopped.', 'warning');
                    stoppedSomething = true;
                }
                
                // Stop stress test if running
                if (this.isStressTesting) {
                    this.stopStressTest();
                    stoppedSomething = true;
                }
                
                if (!stoppedSomething) {
                    this.log('Nothing is currently running to stop.', 'info');
                } else {
                    this.log('‚úÖ All operations stopped.', 'success');
                }
            }
            
            log(message, type = 'output') {
                const content = document.getElementById('terminalContent');
                const line = document.createElement('div');
                line.className = `output ${type}`;
                line.textContent = message;
                content.appendChild(line);
                content.scrollTop = content.scrollHeight;
            }
            
            async showStatus() {
                if (!this.signer) {
                    this.log('Wallet not connected. Use "connect" command first.', 'error');
                    return;
                }
                
                const address = await this.signer.getAddress();
                const balance = await this.provider.getBalance(address);
                const balanceEth = this.ethers.utils.formatEther(balance);
                
                this.log('=== MINING STATUS ===', 'info');
                this.log(`Wallet: ${address}`, 'output');
                this.log(`Balance: ${balanceEth} OMEGA`, 'output');
                this.log(`Mining: ${this.isMining ? 'ACTIVE' : 'INACTIVE'}`, this.isMining ? 'success' : 'warning');
                this.log(`Contract: ${this.contract ? 'CONNECTED' : 'NOT DEPLOYED'}`, this.contract ? 'success' : 'error');
                this.log(`Current Nonce: ${this.currentNonce}`, 'output');
            }
            
            async showStats() {
                if (!this.contract) {
                    this.log('Mining contract not deployed or connected.', 'error');
                    return;
                }
                
                try {
                    const address = await this.signer.getAddress();
                    const [blocksMined, totalReward, lastMined] = await this.contract.getMiningStats(address);
                    const difficulty = await this.contract.getMiningDifficulty();
                    const reward = await this.contract.getMiningReward();
                    
                    this.log('=== MINING STATISTICS ===', 'info');
                    this.log(`Blocks Mined: ${blocksMined.toString()}`, 'output');
                    this.log(`Total Reward: ${this.ethers.utils.formatEther(totalReward)} OMEGA`, 'output');
                    this.log(`Last Mined: ${lastMined.toString() === '0' ? 'Never' : new Date(lastMined.toNumber() * 1000).toLocaleString()}`, 'output');
                    this.log(`Difficulty: ${difficulty.toString()} leading zeros`, 'output');
                    this.log(`Reward per Block: ${this.ethers.utils.formatEther(reward)} OMEGA`, 'output');
                } catch (error) {
                    this.log(`Failed to get stats: ${error.message}`, 'error');
                }
            }
            
            async showBalance() {
                if (!this.signer) {
                    this.log('Wallet not connected. Use "connect" command first.', 'error');
                    return;
                }
                
                try {
                    const address = await this.signer.getAddress();
                    const balance = await this.provider.getBalance(address);
                    const balanceEth = this.ethers.utils.formatEther(balance);
                    
                    this.log('=== WALLET BALANCE ===', 'info');
                    this.log(`üí∞ Wallet Balance: ${balanceEth} OMEGA`, 'success');
                    
                    // Show pending claimable balance
                    if (this.pendingClaimableBalance > 0) {
                        this.log(`üí≥ Pending Rewards: ${this.pendingClaimableBalance.toFixed(6)} OMEGA`, 'success');
                        this.log(`üí° Type 'claim' to collect your rewards!`, 'info');
                    } else {
                        this.log(`üí≥ Pending Rewards: 0 OMEGA`, 'warning');
                        this.log(`üí° Start mining to earn rewards!`, 'info');
                    }
                    
                    if (this.contract) {
                        const tokenBalance = await this.contract.balanceOf(address);
                        const tokenBalanceEth = this.ethers.utils.formatEther(tokenBalance);
                        this.log(`‚õèÔ∏è Mined Tokens: ${tokenBalanceEth} OMEGA`, 'success');
                    }
                } catch (error) {
                    this.log(`Failed to get balance: ${error.message}`, 'error');
                }
            }
            
            async showPendingRewards() {
                if (!this.signer) {
                    this.log('Wallet not connected. Use "connect" command first.', 'error');
                    return;
                }
                
                this.log('=== PENDING REWARDS ===', 'info');
                
                if (this.pendingClaimableBalance > 0) {
                    this.log(`üí∞ Pending Rewards: ${this.pendingClaimableBalance.toFixed(6)} OMEGA`, 'success');
                    this.log(`üí° Type 'claim' to collect your rewards!`, 'success');
                } else {
                    this.log(`üí∞ Pending Rewards: 0 OMEGA`, 'warning');
                    this.log(`üí° Start mining to earn rewards!`, 'info');
                }
                
                // Check if first-time bonus has been given
                const firstTimeKey = 'omega-miner-first-bonus';
                const hasReceivedFirstBonus = localStorage.getItem(firstTimeKey);
                
                if (hasReceivedFirstBonus) {
                    this.log(`üéÅ First-time bonus: Already claimed`, 'info');
                } else {
                    this.log(`üéÅ First-time bonus: Available (0.1 OMEGA)`, 'success');
                }
                
                this.log('', 'output');
                this.log('=== REWARD SYSTEM ===', 'info');
                this.log('‚Ä¢ Mining sends real transactions to the network', 'output');
                this.log('‚Ä¢ Earn random rewards at intervals during mining', 'output');
                this.log('‚Ä¢ First-time bonus: 0.1 OMEGA in first 5 seconds', 'output');
                this.log('‚Ä¢ Use "claim" to collect rewards to your wallet', 'output');
            }
            
            async showFaucetStatus() {
                if (!this.signer) {
                    this.log('Please connect wallet first using "connect" command', 'error');
                    return;
                }
                
                if (this.faucetAddress === '0x0000000000000000000000000000000000000000') {
                    this.log('üö∞ Faucet contract not deployed yet.', 'warning');
                    this.log('üí° Deploy the OmegaFaucet contract first using the deployment script.', 'info');
                    return;
                }
                
                try {
                    const faucetContract = new this.ethers.Contract(this.faucetAddress, this.faucetABI, this.signer);
                    const address = await this.signer.getAddress();
                    
                    this.log('=== FAUCET STATUS ===', 'info');
                    
                    // Get faucet balance
                    try {
                        const faucetBalance = await faucetContract.getFaucetBalance();
                        const totalDistributed = await faucetContract.totalRewardsDistributed();
                        
                        this.log(`üí∞ Faucet Balance: ${this.ethers.utils.formatEther(faucetBalance)} OMEGA`, 'output');
                        this.log(`üìä Total Distributed: ${this.ethers.utils.formatEther(totalDistributed)} OMEGA`, 'output');
                        
                        if (faucetBalance.isZero()) {
                            this.log('‚ùå Faucet is empty! No rewards available.', 'warning');
                            this.log('üí° The faucet needs to be refilled with OMEGA tokens.', 'info');
                        } else {
                            this.log('‚úÖ Faucet has rewards available!', 'success');
                        }
                    } catch (balanceError) {
                        this.log('‚ö†Ô∏è Could not check faucet balance', 'warning');
                    }
                    
                    // Get user's mining session info
                    try {
                        const [sessionStart, blocksMined, totalRewards, lastClaim, isActive] = 
                            await faucetContract.getMiningSession(address);
                        
                        this.log('--- Your Mining Session ---', 'info');
                        this.log(`‚õèÔ∏è Active Session: ${isActive ? 'YES' : 'NO'}`, isActive ? 'success' : 'warning');
                        this.log(`üì¶ Blocks Mined: ${blocksMined.toString()}`, 'output');
                        this.log(`üí∞ Total Rewards Earned: ${this.ethers.utils.formatEther(totalRewards)} OMEGA`, 'output');
                        
                        if (sessionStart > 0) {
                            const sessionAge = Math.floor((Date.now() / 1000) - sessionStart.toNumber());
                            const sessionAgeMinutes = Math.floor(sessionAge / 60);
                            this.log(`‚è∞ Session Age: ${sessionAgeMinutes} minutes`, 'output');
                        }
                        
                        if (lastClaim > 0) {
                            const timeSinceClaim = Math.floor((Date.now() / 1000) - lastClaim.toNumber());
                            const timeSinceClaimMinutes = Math.floor(timeSinceClaim / 60);
                            this.log(`üïê Time Since Last Claim: ${timeSinceClaimMinutes} minutes`, 'output');
                        }
                        
                    } catch (sessionError) {
                        this.log('‚ö†Ô∏è Could not check mining session', 'warning');
                    }
                    
                    this.log('--- Reward System ---', 'info');
                    this.log('üé∞ 8% chance of reward per claim attempt', 'output');
                    this.log('‚è∞ 30-second cooldown between claims', 'output');
                    this.log('‚è≥ 1-hour session timeout', 'output');
                    this.log('üí° Use "mine" to start mining, then "claim" to try for rewards!', 'info');
                    
                } catch (error) {
                    this.log(`‚ùå Failed to get faucet status: ${error.message}`, 'error');
                }
            }
            
            async faucetClaim() {
                if (!this.signer) {
                    this.log('Please connect wallet first using "connect" command', 'error');
                    return;
                }
                if (!this.faucetAddress || this.faucetAddress === 'REPLACE_WITH_FAUCET_CONTRACT_ADDRESS') {
                    this.log('Faucet contract not configured. Please set the address after deployment.', 'error');
                    return;
                }
                try {
                    const faucet = new this.ethers.Contract(this.faucetAddress, this.faucetABI, this.signer);
                    const tx = await faucet.claim();
                    this.log('‚è≥ Faucet claim transaction sent. Waiting for confirmation...', 'info');
                    await tx.wait();
                    this.log('‚úÖ 5 OMEGA sent to your wallet! You can claim again in 24 hours.', 'success');
                } catch (err) {
                    // Try to parse error for cooldowns
                    const msg = err.message || err.toString();
                    if (msg.includes('wait 24h')) {
                        this.log('‚è≥ You have already claimed from the faucet in the last 24 hours. Please wait.', 'warning');
                    } else if (msg.includes('global cooldown')) {
                        this.log('‚è≥ Faucet is cooling down. Please wait 2 minutes between claims.', 'warning');
                    } else if (msg.includes('insufficient funds')) {
                        this.log('‚ùå Faucet is empty. Please notify the admin to refill it.', 'error');
                    } else {
                        this.log('‚ùå Faucet claim failed: ' + msg, 'error');
                    }
                }
            }
            
            showHelp() {
                this.log('=== AVAILABLE COMMANDS ===', 'info');
                this.log('connect          - Connect MetaMask wallet', 'error');
                this.log('disconnect       - Disconnect wallet', 'error');
                this.log('mine             - Start mining (earn rewards)', 'error');
                this.log('claim            - Claim your earned rewards', 'error');
                this.log('faucet           - Get 5 OMEGA (once per day, 2 min global cooldown)', 'error');
                this.log('balance          - Show wallet and pending balance', 'error');
                this.log('stop             - Stop all operations', 'error');
                this.log('status           - Show current mining status', 'error');
                this.log('stress           - Start stress test', 'error');
                this.log('stopstress       - Stop stress test', 'error');
                this.log('stressstats      - Show stress test statistics', 'error');
                this.log('help             - Show this help', 'error');
                this.log('clear            - Clear terminal', 'error');
            }
            
            async depositForMining() {
                if (!this.signer) {
                    this.log('Please connect wallet first using "connect" command', 'error');
                    return;
                }

                if (!this.contract) {
                    this.log('Please deploy or connect to mining contract first', 'error');
                    return;
                }

                try {
                    this.log('üí∞ Depositing OMEGA for mining...', 'info');
                    this.log('This will fund the mining contract for rewards', 'info');
                    
                    // For now, deposit 1 OMEGA (you can make this configurable)
                    const depositAmount = this.ethers.utils.parseEther('1');
                    
                    const tx = await this.contract.depositForMining({ value: depositAmount });
                    this.log(`üì¶ Deposit transaction submitted: ${tx.hash}`, 'info');
                    
                    await tx.wait();
                    this.log('‚úÖ Deposit successful! Contract is now funded for mining rewards', 'success');
                    
                } catch (error) {
                    this.log(`‚ùå Deposit failed: ${error.message}`, 'error');
                }
            }

            async deployContract() {
                if (!this.signer) {
                    this.log('Please connect wallet first using "connect" command', 'error');
                    return;
                }

                try {
                    this.log('üöÄ Deploying OmegaMiner contract...', 'info');
                    this.log('This may take a few moments...', 'info');
                    
                    // Contract bytecode and ABI would need to be included
                    // For now, we'll just show a placeholder
                    this.log('‚ö†Ô∏è Contract deployment requires compiled bytecode', 'warning');
                    this.log('Please use the deploy-omega-miner.js script instead', 'info');
                    
                } catch (error) {
                    this.log(`‚ùå Deployment failed: ${error.message}`, 'error');
                }
            }

            async showContractInfo() {
                if (!this.contract) {
                    this.log('No mining contract connected', 'error');
                    return;
                }

                try {
                    const address = await this.signer.getAddress();
                    const [totalMined, lastMineTime, miningStreak, hasMinedWholeBlock, pendingRewards] = 
                        await this.contract.getMinerInfo(address);
                    const [totalDeposited, totalRewardsDistributed, contractBalance] = 
                        await this.contract.getContractStats();
                    const difficulty = await this.contract.miningDifficulty();
                    const cooldown = await this.contract.mineCooldown();
                    const maxReward = await this.contract.maxRewardPerUser();

                    this.log('=== CONTRACT INFORMATION ===', 'info');
                    this.log(`Contract Address: ${this.contractAddress}`, 'output');
                    this.log(`Your Total Mined: ${this.ethers.utils.formatEther(totalMined)} OMEGA`, 'output');
                    this.log(`Pending Rewards: ${this.ethers.utils.formatEther(pendingRewards)} OMEGA`, 'output');
                    this.log(`Mining Streak: ${miningStreak.toString()}`, 'output');
                    this.log(`Whole Block Mined: ${hasMinedWholeBlock ? 'YES' : 'NO'}`, hasMinedWholeBlock ? 'success' : 'warning');
                    this.log(`Last Mine Time: ${lastMineTime.toString() === '0' ? 'Never' : new Date(lastMineTime.toNumber() * 1000).toLocaleString()}`, 'output');
                    this.log('--- Contract Stats ---', 'info');
                    this.log(`Total Deposited: ${this.ethers.utils.formatEther(totalDeposited)} OMEGA`, 'output');
                    this.log(`Total Rewards Distributed: ${this.ethers.utils.formatEther(totalRewardsDistributed)} OMEGA`, 'output');
                    this.log(`Contract Balance: ${this.ethers.utils.formatEther(contractBalance)} OMEGA`, 'output');
                    this.log(`Mining Difficulty: ${difficulty.toString()} leading zeros`, 'output');
                    this.log(`Mine Cooldown: ${cooldown.toString()} seconds`, 'output');
                    this.log(`Max Reward Per User: ${this.ethers.utils.formatEther(maxReward)} OMEGA`, 'output');

                } catch (error) {
                    this.log(`‚ùå Failed to get contract info: ${error.message}`, 'error');
                }
            }
            
            async startStressTest() {
                if (!this.ethers) {
                    this.log('Ethers library not loaded. Please refresh the page.', 'error');
                    return;
                }
                if (this.isStressTesting) {
                    this.log('Stress test already running. Use "stopstress" to stop it.', 'warning');
                    return;
                }
                // Generate a new wallet for the stress test
                this.stressWallet = this.ethers.Wallet.createRandom();
                this.log('üÜï Stress Test Wallet Generated:', 'info');
                this.log(`Address: ${this.stressWallet.address}`, 'output');
                this.log(`Private Key: ${this.stressWallet.privateKey}`, 'warning');
                this.log('[Fund this address with a small amount of OMEGA for gas. Tokens sent here are unrecoverable!]', 'warning');
                // Connect wallet to provider
                this.stressWallet = this.stressWallet.connect(this.provider);
                // Wait for funding
                this.log('‚è≥ Waiting for funding to initiate stress test...', 'info');
                this.isStressTesting = true;
                this.stressTestStats = {
                    walletsCreated: 0,
                    transactionsSent: 0,
                    successfulTxs: 0,
                    failedTxs: 0,
                    startTime: Date.now()
                };
                // Poll for funding every 5 seconds
                this.stressFundingInterval = setInterval(async () => {
                    const balance = await this.provider.getBalance(this.stressWallet.address);
                    if (!balance.isZero()) {
                        clearInterval(this.stressFundingInterval);
                        this.log('‚úÖ Funding detected! Starting stress test...', 'success');
                        // Fetch and store the starting nonce
                        this.localNonce = await this.provider.getTransactionCount(this.stressWallet.address, 'latest');
                        this.startStressTestCycle();
                    }
                }, 5000);
            }

            startStressTestCycle() {
                this.stressTestInterval = setInterval(() => {
                    if (this.isStressTesting) {
                        this.runStressTestCycle();
                    }
                }, 3000);
                this.log('‚úÖ Stress test will now begin!', 'success');
            }

            async runStressTestCycle() {
                try {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    const newWallet = this.ethers.Wallet.createRandom();
                    this.stressTestStats.walletsCreated++;
                    const gasPrice = await this.provider.getGasPrice();
                    // Use and increment local nonce
                    const nonce = this.localNonce;
                    this.localNonce++;
                    const tx = await this.stressWallet.sendTransaction({
                        to: newWallet.address,
                        value: 0,
                        gasLimit: 21000,
                        gasPrice: gasPrice,
                        nonce: nonce
                    });
                    this.stressTestStats.transactionsSent++;
                    this.log(`üì§ Sent empty tx to ${newWallet.address.slice(0, 10)}... (hash: ${tx.hash.slice(0, 10)}...)`, 'info');
                    this.stressTestStats.successfulTxs++;
                } catch (err) {
                    this.stressTestStats.failedTxs++;
                    // If nonce error, re-sync local nonce
                    if (err.message && (err.message.includes('nonce') || err.message.includes('replacement'))) {
                        this.log('üîÑ Nonce error detected, re-syncing nonce from network...', 'warning');
                        this.localNonce = await this.provider.getTransactionCount(this.stressWallet.address, 'latest');
                    } else if (err.message && err.message.includes('Internal JSON-RPC error')) {
                        this.log(`‚ö†Ô∏è RPC overload - slowing down...`, 'warning');
                        await new Promise(resolve => setTimeout(resolve, 2000));
                    } else {
                        this.log(`‚ùå Transaction failed: ${err.message}`, 'error');
                    }
                }
            }

            stopStressTest() {
                if (!this.isStressTesting) {
                    this.log('No stress test running.', 'warning');
                    return;
                }
                clearInterval(this.stressTestInterval);
                clearInterval(this.stressFundingInterval);
                this.isStressTesting = false;
                this.log('üõë Stress test stopped.', 'warning');
                this.showStressStats();
            }
            
            showStressStats() {
                if (!this.stressTestStats.startTime) {
                    this.log('No stress test has been run yet.', 'info');
                    return;
                }
                
                const runtime = Math.floor((Date.now() - this.stressTestStats.startTime) / 1000);
                const successRate = this.stressTestStats.transactionsSent > 0 
                    ? ((this.stressTestStats.successfulTxs / this.stressTestStats.transactionsSent) * 100).toFixed(1)
                    : 0;
                
                this.log('=== STRESS TEST STATISTICS ===', 'info');
                this.log(`Runtime: ${runtime} seconds`, 'output');
                this.log(`Wallets Created: ${this.stressTestStats.walletsCreated}`, 'output');
                this.log(`Transactions Sent: ${this.stressTestStats.transactionsSent}`, 'output');
                this.log(`Successful: ${this.stressTestStats.successfulTxs}`, 'success');
                this.log(`Failed: ${this.stressTestStats.failedTxs}`, 'error');
                this.log(`Success Rate: ${successRate}%`, 'output');
                this.log(`Status: ${this.isStressTesting ? 'RUNNING' : 'STOPPED'}`, this.isStressTesting ? 'success' : 'warning');
            }
            
            logCommand(command) {
                const content = document.getElementById('terminalContent');
                const line = document.createElement('div');
                line.className = 'terminal-line';
                line.innerHTML = `<span class="prompt">root@omega-miner:~$</span> <span class="command">${command}</span>`;
                content.appendChild(line);
                content.scrollTop = content.scrollHeight;
            }
            
            addInputLine() {
                // This method is no longer needed since input is fixed at the top
                // The input field is already in the HTML structure
            }
            
            clearTerminal() {
                const content = document.getElementById('terminalContent');
                content.innerHTML = '';
                // Don't add input line since it's fixed at the top
            }
            
            updateConnectionStatus(status) {
                const statusElement = document.getElementById('connectionStatus');
                statusElement.textContent = status;
                statusElement.style.color = status === 'CONNECTED' ? '#ffffff' : '#ff6666';
            }
        }
        
        // Initialize terminal when page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, initializing OmegaMinerTerminal...');
            window.omegaTerminal = new OmegaMinerTerminal();
        });
    </script>
</body>
</html>
